.TH transcode 1 "6th January 2004" "transcode(1)"
.SH NAME
transcode \- LINUX video stream processing tool
.SH SYNOPSIS
.B transcode
[ -i name ]
[ -H n ]
[ -p file ]
.br
[ -x vmod[,amod] ]
[ -a a[,v] ]
[ --dvd_access_delay N ]
.br
[ -e r[,b[,c]] ]
[ -E r[,b[,c]] ]
[ -n 0xnn ]
[ -N 0xnn ]
.br
[ -b b[,v[,q[,m]]] ]
[ --no_audio_adjust ]
.br
[ --no_bitreservoir ]
[ --lame_preset name[,fast] ]
.br
[ -g wxh ]
[ --import_asr C ]
[ --export_asr C ]
.br
[ --export_par N,D ]
[ --keep_asr ]
[ -f rate[,frc] ]
.br
[ --export_fps f[,c] ]
[ --export_frc F ]
[ --hard_fps  ]
.br
[ -o file ]
[ -m file ]
[ -y vmod[,amod] ]
[ -F codec ]
.br
[ --avi_limit N ]
[ --avi_comments F ]
[ -d ]
.br
[ -s g[,c[,f[,r]]] ]
[ -u m[,n] ]
[ -A ]
[ -V format ]
.br
[ -J f1[,f2[,...]] ]
[ -P flag ]
[ -D num ]
.br
[ --av_fine_ms t ]
[ -M mode ]
[ -O ]
[ -r n[,m] ]
.br
[ -B n[,m[,M]] ]
[ -X n[,m[,M]] ]
[ -Z wxh[,fast|interlaced] ]
.br
[ --zoom_filter str ]
[ -C mode ]
[ --antialias_para w,b ]
.br
[ -I mode ]
[ -K ]
[ -G val ]
[ -z ]
[ -l ]
[ -k ]
.br
[ -j t[,l[,b[,r]]] ]
[ -Y t[,l[,b[,r]]] ]
.br
[ --pre_clip t[,l[,b[,r]]] ]
[ --post_clip t[,l[,b[,r]]] ]
.br
[ -w b[,k[,c]] ]
[ --video_max_bitrate ]
.br
[ -R n[,f1[,f2]] ]
[ -Q n[,m] ]
[ --divx_quant min,max ]
.br
[ --divx_rc p,rp,rr ]
[ --divx_vbv_prof N ]
.br
[ --divx_vbv br,sz,oc ]
[ -c f1-f2[,f3-f4] ]
[ -t n,base ]
.br
[ --dir_mode base ]
[ --frame_interval N ]
[ -U base ]
.br
[ -T t[,c[-d][,a]] ]
[ -W n,m[,file] ]
.br
[ --cluster_percentage use ]
[ --cluster_chunks a-b ]
.br
[ -S unit[,s1-s2] ]
[ -L n ]
.br
[ --pulldown ]
[ --encode_fields ]
[ --nav_seek file ]
.br
[ --psu_mode ]
[ --psu_chunks a-b ]
[ --no_split ]
.br
[ --ts_pid 0xnn ]
[ --a52_drc_off ]
[ --a52_demux ]
.br
[ --a52_dolby_off ]
[ --progress_meter N ]
.br
[ --progress_rate N ]
[ --color N ]
[ --write_pid file ]
.br
[ --nice N ]
[ --accel type ]
[ --socket file ]
.br
[ --dv_yuy2_mode ]
[ --dv_yv12_mode ]
[ --config_dir dir ]
.br
[ --export_prof S ]
.br
[ --mplayer_probe ]
.br
[ -q level ]
[ -h ]
[ -v ]
.SH COPYRIGHT
\fBtranscode\fP is Copyright (C) 2001-2003 by Thomas Östreich, 2003-2004 Tilmann
Bitterberg.
.SH DESCRIPTION
.LP
\fItranscode\fP is a linux text-console utility for video stream
processing, running on a platform that supports shared libraries and
threads.
.LP
Decoding and encoding is done by loading modules that are responsible
for feeding transcode with raw video/audio streams (import modules)
and encoding the frames (export modules).
.LP
It supports elementary video and audio frame transformations,
including de-interlacing or fast resizing of video frames and loading
of external filters.
.LP
A number of modules are included to enable import of DVDs on-the-fly,
MPEG elementary (ES) or program streams (VOB), MPEG video, Digital
Video (DV), YUV4MPEG streams, NuppelVideo file format, AVI
based codecs and raw or compressed (pass-through) video
frames and export modules for writing DivX;-), XviD, DivX
4.xx/5.xx or uncompressed AVI and raw files with MPEG, AC3
(pass-through) or PCM audio.
.LP
Additional export modules to write single frames (PPM) or YUV4MPEG
streams are available, as well as an interface import module to the
avifile library.
.LP
It's modular concept is intended to provide flexibility and easy user
extensibility to include other video/audio codecs or filetypes. A set
of tools is included to demux (tcdemux), extract (tcextract) and
decode (tcdecode) the sources into raw video/audio streams for import,
probing (tcprobe) and scanning (tcscan) your sources and to enable
post-processing of AVI files, fixing AVI file header information
(avifix), merging multiple files (avimerge), splitting large AVI
files (avisplit) to fit on a CD and avisync to correct
AV-offsyncs.
.SH OPTIONS

.TP
.B \-A
use AC3 as internal audio codec [off].
.br
Only pass-through supported.

.TP
.B \-B \fIn\fP[\fI,m\fP[,\fIM\fP]]
resize to height-\fIn\fP*\fIM\fP rows [,width-\fIm\fP*\fIM\fP] columns
[off,32]. \fIM\fP must be one of 8, 16 or 32. It makes no difference which M you use.
You might look at the \fIfast\fP flag of the \fB-Z\fP option if you don not
want to calculate \fIn\fP and \fIm\fP yourself.

.TP
.B \-C \fImode\fP
enable anti-aliasing mode (1-3) [off].
.RS
.TP 4
.I 1
de-interlace effects only
.TP
.I 2
resize effects only
.TP
.I 3
process full frame (slow)
.RE

.TP
.B \-D \fInum\fP
sync video start with audio frame num [0].
.TP
.B \-E \fIr\fP[\fI,b\fP[\fI,c\fP]]
audio output samplerate [Hz], bits per sample and channels [as input]. The option "-J resample" must be provided for export modules not capable of re-sampling. Samplerate and bits per sample can be specified as 0 to mean "same as input"; this allows converting from stereo to mono while leaving the other parameters alone (-E 0,0,1).

.TP
.B \-F \fIcodec_string\fP
encoder parameter strings [module dependent].
.br
The \-F parameter has different meanings for different export modules.
.br

-y \fIffmpeg\fP:
  The codec String for the codec you want to encode. Example values are -F mpeg4 or -F mpeg1video or -F huffyuv. To get a list of valid codecs, use -F list

-y \fIim\fP:
  The name of the image format you want to export. Example values are '-F jpg' (default) or '-F png' or -F 'gif'. With -F jpg, -w gives quality in percent. With -F png, the first digit of -w gives compression level, the second one gives quality, so -w 95 selects best compression level (9) and 5 means PNG adaptive filtering.

-y \fIjpg\fP:
  The quality of the JPEG encode in percent. Example values are '-F 75' (default) or '-F 100'

-y \fImov\fP:
  Syntax: -F "<vcodec>,<acodec>[,<parameters>]"
    <vcodec> = Videocodec to encode with. Default: "mjpa"
    <acodec> = Audiocodec to encode with. Default: "ima4"
    <parameters> = A comma seperated list of parameters
                   to be passed to the codec.

Note: You can use "list" instead of a video/audiocodec or parameter to get a list of supported options.

-y \fImpeg\fP:
  Syntax: -F "<base-profile>[,<resizer-mode>[,user-profile]]"
    <base-profile> can be one of
      '1' = MPEG 1 (default)
      'b' = big MPEG 1 (experimental)
      'v' = VCD
      's' = SVCD
      '2' = MPEG2
      'd' = DVD compliant
    <resizer-mode> can be one of
       0 = disable resizer (default)
       1 = 352x288
       2 = 480x480
       3 = 480x576
       4 = 352x240
    <user-profile> is a filename of the profile file. You can either specify the absolute path to the file or if you transcode will look for it in the directory where you started transcode.

-y \fImpeg2enc\fP:
  Syntax: -F "<base-profile>[,<options_string>]"
    <base-profile> can be one of
      '0' = Generic MPEG1 (default)
      '1' = Standard VCD
      '2' = User VCD
      '3' = Generic MPEG2
      '4' = Standard SVCD
      '5' = User SVCD
      '6' = Manual parameter mode
      '8' = DVD
    <options_string> will be passed down to mpeg2enc untouched by transcode. Have a look at the manpage for mpeg2enc.

-y \fIraw\fP:
  The name of the image format to use for uncompressed video. Examples are I420 (YUV 4:2:0 planar), YV12 (the same thing with U and V reversed), or UYVY (YUV 4:2:2 packed). Use "-F help" to get a list of formats.


.TP
.B \-G \fIval\fP
Gamma correction (0.0-10.0) [off].
.br
A value of 1.0 does not change anything. A value lower than 1.0 will make the
picture "brighter", a value above 1.0 will make it "darker".

.TP
.B \-H \fIn\fP
auto-probe \fIn\fP MB of source (0=disable) default [1]
.br
Use a higher value than the default to detect all subtitles in the VOB.

.TP
.B \-I \fImode\fP
enable de-interlacing mode (1-5) [off].
.RS
.TP 4
.I 1
"interpolate scanlines"
.br
linear interpolation (takes the average of the surronding even rows to
determine the odd rows), and copies the even rows as is.
.TP
.I 2
"handled by encoder"
.br
tells the encoding code to handle the fact that the frames are interlaced. Most
codecs do not handle this.
.TP
.I 3
"zoom to full frame"
.br
drops to to half size, then zooms out. This can cause excessive blurring which
is not always unwanted. On the other hand results are quite good.
.TP
.I 4
"drop field / half height"
.br
drop every other field and keep half height.
.TP
.I 5
"interpolate scanlines / blend frames"
.br
linear blend (similar to -vop pp=lb in mplayer) this, like linear blend
calculates the odd rows as the average of the surrounding even rows, and also
calculates the even rows as an average of the original even rows and also
calculates the even rows as an average of the original odd rows and averages
the calculated and original rows. Something like avg (avg(row1,row3), avg(row2, row4))
.RE

.TP
.B \-J \fIfilter1\fP[\fI,filter2\fP[\fI,...\fP]]
apply external filter plugins [off].
A full-blown transcode installation has the following filter modules:
.IP
See the section
.BI FILTERS
for details.
.IP
To see what filters are available at your installation of transcode, execute
.nf
.B \	ls -1 `tcmodinfo -p`/filter*.so
.fi
Example:
.RS

.nf
transcode [...]
  \-J 32detect=force_mode=3,normalize,cut="0-100 300-400"
.fi

Will load the 32detect filter plugin with parameter force_mode=3, the
volume normalizer and the cut filter.
.RE
.IP
.B Note:
.RS
You can specify more than one \-J argument. The order of filter arguments
specify in which order the filters are applied. Note also, for transcode
internally it makes no difference whether you do "\-J filter1 \-J filter2"
or "\-J filter1,filter2"

Use 'tcmodinfo -i \fINAME\fP' to get more information about the
filter_\fINAME\fP. Not all filters support this but most of them do. Some of
the filter plugins have additional documentation in the docs/ directory.
The
.BI FILTERS
section documents nearly every filter which might be of use.
.RE

.TP
.B \-L \fIn\fP
seek to VOB stream offset \fIn\fPx2kB default [0]
.br
This option is usually calculated automatically when giving --nav_seek and -c.
.TP

.B \-K
enable black/white by removing colors mode (grayscale) [off].
.br
Please note this does not necessarily lead to a smaller image / better compression.
.br
For YUV mode, this is done by emptying the chroma planes, for RGB mode a
weightend grayscale value is computed.

.TP
.B \-M \fImode\fP
demuxer PES AV sync modes (0-4) [1].

.RS
.TP 0
.I Overview
The demuxer takes care that the right video frames go together with the right
audio frame. This can sometimes be a complex task and transcode tries to aid you
as much as possible.
.br
WARNING: It does make a difference if you (the user) specifies a demuxer to use
or if transcode resp. tcprobe(1) chooses the one which it thinks is right for
your material.
.br
This is done on purpose to avoid mystic side-effects. So think twice, wether you
specify a demuxer or let transcode choose one or you might end up with an
off-sync result.
.TP 4
.I 0
Pass-through.
Do not mess with the stream, switch off any synchronization/demuxing process.
.TP
.I 1
PTS only (default)
Synchronize video and audio by inspecting PTS/DTS time stamps of audio and
video. Preferred mode for PAL VOB streams and DVDs.
.TP
.I 2
NTSC VOB stream synchronization feature.
This mode generates synchronization information for transcode by
analyzing the frame display time.
.TP
.I 3
(like -M 1): sync AV at initial PTS,
but invokes "-D/--av_fine_ms" options internally based on "tcprobe" PTS
analysis. PTS stands for Presentation Time Stamp.
.TP
.I 4
(like -M 2): initial PTS / enforce frame rate,
with additional frame rate enforcement (for NTSC).
.RE

.TP
.B \-N \fI0xNN\fP
export audio format id [0x55].
.RS
Available format IDs are:
.TP 8
.I 0x1
PCM uncompressed audio
.TP
.I 0x50
MPEG layer-2 aka MP2
.TP
.I 0x55
MPEG layer-3 aka MP3.
Also have a look at --lame_preset
if you intend to do VBR audio.
.TP
.I 0x2000
AC3 audio
.TP
.I 0xfffe
OGG/Vorbis audio
.RE

.TP
.B \-O
flush lame mp3 buffer on encoder stop [off].

.TP
.B \-P \fIflag\fP
pass-through flag (0=off|1=V|2=A|3=A+V) [0].
.br
Pass-through for \fIflag\fP != 1 is broken and not a trivial thing to fix.
.IP
You can pass-through DV video, AVI files and MPEG2 video. When doing MPEG2
pass-through (together with the -y raw module), you can give a requantization
factor by using -w -- for example -w 1.5 -- this will make the MPEG2 stream
smaller.
.IP
The pass-through mode is useful for reconstruction of a broken index of an AVI
file. The -x ffmpeg import-module analyzes the compressed bitstream and can
detect a keyframe for DIV3, MPEG4 (DivX, XviD, ..) and other formats. It then
sets an internal flag which the export module will respect when writing the
frame out.

.TP
.B \-Q \fIn\fP[\fI,m\fP]
encoding[,decoding] quality (0=fastest-5=best) [5,5].

.TP
.B \-R \fIn\fP[\fI,f1\fP[\fI,f2\fP]]
enable multi-pass encoding (0-3) [0,divx4.log,pcm.log].
.RS
.TP 4
.I 0\fR Constant bitrate (CBR) encoding. [default]
The codec tries to achieve constant bitrate output. This means, each encoded
frame is mostly the same size. This type of encoding can help in maintaining
constant filling of hardware buffer on set top players or smooth streaming
over networks. By the way, Constant bitrate is often obtained sacrifying
quality during high motion scenes.
.TP
.I 1\fR Variable bitrate encoding: First pass.
In this mode, the codec analyses the complete sequence in order to collect
data that can improve the distribution of bits in a second VBR pass. The
collected data is written to second sub argument (default: divx4.log). This
data is codec dependant and cannot be used across codecs. It is strongly
advised to use the same codec settings for the VBR analysis pass and the
VBR encoding pass if you want predictable results.
.IP
The video output of the first pass is not of much use and can grow very large.
It's a good idea to not save the video output to a file but directly to /dev/null.
Usually the bitrate is ignored during first pass.
.IP
Disabling audio export makes sense too, so use -y codec,null. It is \fBnot\fP
recommended to disable the audio \fBimport\fP because transcode might drop
video frames to keep audio and video in sync. This is not possible when the
audio import is disabled. It may lead to the fact that the codec will see a
different sequence of frames which effectively renders the log file invalid.
.TP
.I 2\fR Variable bitrate encoding: Second pass.
The first pass allowed the codec collecting data about the complete sequence.
During the second pass, the codec will use that data in order to find an
efficient bit distribution that respects both the desired bitrate and the
natural bitrate curve shape. This ensures a good compromise between quality
and desired bitrate.
.IP
Make sure you activate both sound and video encoding during this pass.
.TP
.I 3\fR Constant quantizer encoding.
The quantizer is the "compression level" of the picture. The lower the
quantizer is, the higher is the quality of the picture. This mode can help
in making sure the sequence is encoded at constant quality, but no prediction
can be made on the final bitrate. When using this mode, the \fB-w\fP option
changes its meaning, it now takes the quantizer ranging from 1 to 31. Note
that constant quantizer encoding is not supported with some codecs (notably
mpeg1/2/4 with -y ffmpeg).
.RE

.TP
.B \-S \fIunit\fP[\fI,s1-s2\fP]
process program stream unit[,s1-s2] sequences [0,all].
.br
This option is a bit redundant to --psu*. This option lets you specify which
units you want to have decoded or skipped. At a program stream unit boundary,
all (internal) mpeg timers are reset to 0. tcprobe will tell you how many units
are in one file.

.TP
.B \-T \fIt\fP[\fI,c\fP[\fI,a\fP]]
select DVD title[,chapter[,angle]] [1,1,1]. Only a single chapter
is transcoded. Use -T 1,-1 to trancode all chapters in a row. You can
even specify chapter ranges.

.TP
.B \-U \fIbase\fP
process DVD in chapter mode to base-ch%02d.avi [off].

.TP
.B \-V \fIformat\fP
select video layout / colour space for internal processing.
Possible values for this options are: yuv420p (default), yuv422p, rgb24
.IP
yuv420p is default because it is most codecs' internal format
so there is no need for conversions. Some modules may
not support it though: use rgb in that case.
.IP
rgb24 is the old (pre-0.6.13) transcode internal format.
Most codecs do not support this format natively and have to
convert it to/from YUV first, so only use this option if you're
really sure or you want to use a module that doesn't support YUV.
.IP
yuv422p is an experimental feature and a developers playground. Not many import,
export and filter modules support this colorspace. A 4:2:2 colorspace offers
much more quality than the consumer oriented 4:2:0 colorspaces like I420/YV12.
Most equipment in film and video post-production uses YUV422. YUV422 doubles
the precision for chroma (color difference) information in the image.
.IP
All internal transformations are supported in YUV422 mode (clipping, flipping,
zooming, etc).

.TP
.B \-W \fIn\fP,\fIm\fP[,\fInav_file\fP]
autosplit and process part \fIn\fP of \fIm\fP (VOB only) [off]

.TP
.B \-X \fIn\fP[,\fIm\fP,[\fIM\fP]]
resize to height+\fIn\fP*\fIM\fP rows [,width+\fIm\fP*\fIM\fP] columns [off,32]. M must be one of 8, 16 or 32. It makes no difference which M you use.
You might look at the \fIfast\fP flag of the \fB-Z\fP option if you do not
want to calculate \fIn\fP and \fIm\fP yourself.

.TP
.B \-Y \fItop\fP[\fI,left\fP[\fI,bottom\fP[\fI,right\fP]]]
select (encoder) frame region by clipping border. Negative values add a border [off].

.TP
.B \-Z \fIwidth\fPx\fIheight\fP[\fI,fast|interlaced\fP]
resize to \fIwidth\fP columns, \fIheight\fP rows with filtering [off,notfast,notinterlaced].
.br
If \fIfast\fP is given, transcode will calculate the parameters for \fB-X\fP
and/or \fB-B\fP. The option \fIfast\fP can only be used when
the import and export geometry of an image is a multiple of 8.

In fast mode, a faster but less precise resizing algorithm will be used
resulting in a slightly less good quality. Beside this (small) drawback, it is
worth a try.

If \fIinterlaced\fP is given, transcode will assume the frame is interlaced
when resizing, and resize each field independently. This will give better
results on interlaced video, but is incompatible with fast mode. Also, the
height (both old and new) must be a multiple of 4.

It is also possible to omit \fIwidth\fP OR \fIheight\fP. In this case,
transcode will calculate the missing value using the import aspect ratio. The
new value will be aligned to be a multiple of 8. Using an additional \fIfast\fP
or \fIinterlaced\fP is also possible.

Examples (assume input is a 16:9 coded file at 720x576):
.nf
   -Z 576x328           uses filtered zoom.
   -Z 576x328,fast      uses fast zoom.
   -Z 576x,fast         guess 328 and do fast zoom.
   -Z x328,interlaced   guess 576 and do interlaced zoom.
.fi

If you also set --export_prof, you can use just "fast" to indicate that fast
resizing is wanted (likewise with "interlaced").

.TP
.B \-a \fIach\fP[\fI,vch\fP]
extract audio[,video] track for encoding.

.TP
.B \-b \fIb\fP[,\fIv\fP,[\fIq\fP,[\fIm\fP]]]
audio encoder bitrate kBits/s[,vbr[,quality[,mode]]] [128,0,5,0]

The \fImode\fP parameter specifies which modus lame should use for encoding.
Available modes are:
.RS 8
.TP 4
.I 0
Joint Stereo (default)
.TP
.I 1
Full stereo
.TP
.I 2
Mono
.RE

.TP
.B \-c \fIf1\fP\-\fIf2\fP[,\fIf3\fP\-\fIf4\fP[, ... ] ]
encode only frames \fIf1\-f2\fP [and \fIf3\-f4\fP]. Default is to encode
all available frames.  Use this and you'll get statistics about remaining
encoding time. The \fIf[N]\fP parameters may also be timecodes in the
HH:MM:SS.FRAME format. Example:
.RS
.nf
\-c 500\-0:5:01,:10:20\-1:18:02.1
.fi
.IP
Will encode only from frame 500 to 5 minutes and 1 second and from 10 min,
20 sec to 1 hour, 18 min, 2 sec and one frame.
.RE
.IP
Note that transcode starts counting frames at \fI0\fP and excludes the last
frame specified. That means that "-c 0-100" will encoded 100 frames starting at
frame \fI0\fP up to frame \fI99\fP

.TP
.B \-d
swap bytes in audio stream [off].
.br
In most cases, DVD PCM audio tracks require swapping of audio bytes

.TP
.B \-e \fIr\fP[\fI,b\fP[\fI,c\fP]]
PCM audio stream parameter. Sample rate [Hz], bits per sample and
number of channels [48000,16,2]. Normally this is autodetected.

.TP
.B \-f \fIrate\fP[,\fIfrc\fP]
import video frame rate[,frc] [25.000,0]. If \fIfrc\fP (frame rate code) is specified,
transcode will calculate the precise frames per second internally. Valid values
for \fIfrc\fP are:
.RS 8
.TP 4
.I 1
23.976 (24000/1001.0)
.TP
.I 2
24
.TP
.I 3
25
.TP
.I 4
29.970 (30000/1001.0)
.TP
.I 5
30
.TP
.I 6
50
.TP
.I 7
59.940 (2 * 29.970)
.TP
.I 8
60
.TP
.I 9
1
.TP
.I 10
5
.TP
.I 11
10
.TP
.I 12
12
.TP
.I 13
15
.RE

.TP
.B \-g \fIWidth\fPx\fIHeight\fP
video stream frame size [720x576].

.TP
.B \-h
print out usage information.

.TP
.B \-i \fIname\fP
input file/directory/device/mountpoint/host name, default is [/dev/zero].

.TP
.B \-j \fItop\fP[\fI,left\fP[\fI,bottom\fP[\fI,right\fP]]]
select frame region by clipping border. Negative values add a border [off].

.TP
.B \-k
swap red/blue (Cb/Cr) in video frame [off]. Use if people have blue faces.

.TP
.B \-l
mirror video frame [off].

.TP
.B \-m \fIfile\fP
write audio stream to separate file [off].

.TP
.B \-n \fI0xnn\fP
import audio format id [0x2000]. Normally, this is autodetected.

.TP
.B \-o \fIfile\fP
output file name, default is [/dev/null].

.TP
.B \-p \fIfile\fP
read audio stream from separate file [off].

.TP
.B \-q \fIdebuglevel\fP
possible values for debuglevel:
.RS
.TP 4
.I 0
QUIET
.TP
.I 1
INFO
.TP
.I 2
DEBUG
.TP
.I 4
STATS
.TP
.I 8
WATCH
.TP
.I 16
FLIST
.TP
.I 32
VIDCORE
.TP
.I 64
SYNC
.TP
.I 128
COUNTER
.TP
.I 256
PRIVATE
.RE

.TP
.B \-r \fIn\fP[,\fIm\fP]
reduce video height/width by n[,m] [off]. Example: \-r \fI2\fP will rescale the
framesize of a 720x576 file to 360x288.

.TP
.B \-s \fIgain\fP,[\fIcenter\fP,[\fIfront\fP,[\fIrear\fP]]]
increase volume of audio stream by gain,[center,front,rear] default [off,1,1,1].

.TP
.B \-t \fIn\fP,\fIbase\fP
split output to \fIbase\fP%03d.avi with \fIn\fP frames [off].

.TP
.B \-u \fIm\fP[\fI,n\fP]
use \fIm\fP framebuffer[,\fIn\fP threads] for AV processing [10,1].

.TP
.B \-v
print version.

.TP
.B \-w \fIb\fP[\fI,k\fP[\fI,c\fP]]
encoder bitrate[,keyframes[,crispness]] [(6000 for MPEG 1/2, 1800 for others),250,100].

.TP
.B \-\-video_max_bitrate \fIb\fP
Use \fIb\fP as maximal bitrate when encoding variable bitrate MPEG-2 streams

.TP
.B \-x \fIvmod\fP[\fI,amod\fP]
video[,audio] import modules [auto,auto]. If omitted, transcode will probe
for appropriate import modules. A full-blown transcode installation has the following import modules:
.RS
.\" Here starts the generated import part, produced by make-module-man.sed
.TP 4
\fBac3\fP \- (audio) AC3
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
decodes AC3 audio from MPEG program streams or raw streams.
.br
Supported processing formats: audio - PCM AC3, video - none
.RE
.TP 4
\fBavi\fP \- (video) * | (audio) *
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
RGB/PCM from RIFF AVI files.
.br
Supported processing formats: audio - RAW (pass-through) PCM, video - RAW (pass-through) RGB YUV YUV420
.RE
.TP 4
\fBbktr\fP \- (video) bktr
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
grabs video frames from bktr(4) devices on BSD systems
.br
Supported processing formats: audio - none, video - RGB YUV YUV420
.RE
.TP 4
\fBdv\fP \- (video) DV | (audio) PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Digital Video and PCM audio from RIFF AVI-files or raw streams.
.br
Supported processing formats: audio - PCM, video - RAW (pass-through) RGB YUV DV YUV420
.RE
.TP 4
\fBdvd\fP \- (video) DVD | (audio) MPEG/AC3/PCM
.br
At compile-time libdvdread must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
on-the-fly DVD transcoding.
.br
Supported processing formats: audio - PCM AC3, video - RGB YUV
.RE
.TP 4
\fBffmpeg\fP \- (video) FFmpeg: MSMPEG/MPEG/MJPEG
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
interface to ffmpeg library supported video codecs and file formats
.br
Supported processing formats: audio - none, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBim\fP \- (video) RGB
.br
At compile-time ImageMagick must be available.
At run-time ImageMagick must be present.
Support for this module is fair.
.RS 8
interface to ImageMagick library supported picture codecs and file formats for making animations. Reads images with a counter pattern.
.br
Supported processing formats: audio - none, video - RAW (pass-through) RGB
.RE
.TP 4
\fBimlist\fP \- (video) RGB
.br
At compile-time ImageMagick must be available.
At run-time ImageMagick must be present.
Support for this module is fair.
.RS 8
interface to ImageMagick library supported picture codecs and file formats for making animations. Reads images from a list.
.br
Supported processing formats: audio - RAW (pass-through), video - RAW (pass-through) RGB
.RE
.TP 4
\fBlve\fP \- (video/audio) MPEG/VOB/LVE
.br
At compile-time liblve must be available.
This module has no run-time dependencies.
Support for this module is fair.
.RS 8
imports video from an LVE edit list
.br
Supported processing formats: audio - PCM, video - YUV
.RE
.TP 4
\fBlzo\fP \- (video) LZO
.br
At compile-time lzo must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
imports AVI-files with LZO loss-less compression for video.
.br
Supported processing formats: audio - RAW (pass-through) PCM, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBmov\fP \- (video) * | (audio) *
.br
At compile-time libquicktime must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Quicktime file format, audio/video codecs supported by quicktime4linux.
.br
Supported processing formats: audio - PCM, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBmp3\fP \- (audio) MPEG
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
MPEG audio from program streams or raw streams.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBmpeg2\fP \- (video) MPEG2
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
video track from MPEG program streams or raw streams, extracted and decoded by mpeg2dec.
.br
Supported processing formats: audio - none, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBmplayer\fP \- (video) rendered by mplayer | (audio) rendered by mplayer
.br
This module has no compile-time dependencies.
At run-time mplayer must be present.
Support for this module is fair.
.RS 8
interface to Mplayer for decoding unsupported codecs, exotic file formats or more ore less broken sources.
.br
Supported processing formats: audio - PCM, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBnull\fP \- (video) null | (audio) null
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is fair.
.RS 8
dummy module, reads from /dev/zero.
.br
Supported processing formats: audio - none, video - none
.RE
.TP 4
\fBnuv\fP \- (video) YUV | (audio) PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is fair.
.RS 8
interface to NuppelVideo file format.
.br
Supported processing formats: audio - PCM, video - YUV
.RE
.TP 4
\fBogg\fP \- (video) all | (audio) Ogg Vorbis
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
decodes Ogg Vorbis audio streams.
.br
Supported processing formats: audio - RAW (pass-through) PCM, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBraw\fP \- (video) RGB/YUV | (audio) PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is fair.
.RS 8
RGB/PCM from RIFF AVI/WAVE files or raw streams.
.br
Supported processing formats: audio - PCM, video - RGB YUV YUV420
.RE
.TP 4
\fBsunau\fP \- (audio) pcm
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
grabs raw PCM audio from audio(4) devices on some BSD systems
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBv4l\fP \- (video) v4l | (audio) PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is fair.
.RS 8
interface for grabbing sound/video from v4l devices on linux systems.
.br
Supported processing formats: audio - PCM, video - RGB YUV
.RE
.TP 4
\fBv4l2\fP \- (video) v4l2 | (audio) pcm
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
interface for grabbing sound/video from v4l2 devices on linux systems. prefered over import_v4l.
.br
Supported processing formats: audio - PCM, video - RGB YUV YUV420
.RE
.TP 4
\fBvnc\fP \- (video) VNC
.br
This module has no compile-time dependencies.
At run-time vncrec must be present.
Support for this module is fair.
.RS 8
imports video from the vncrec program.
.br
Supported processing formats: audio - none, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBvob\fP \- (video) MPEG-2 | (audio) MPEG/AC3/PCM | (subtitle)
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
MPEG/AC3 program streams in VOB files (found on unencrypted/ripped DVDs).
.br
Supported processing formats: audio - PCM AC3, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBxml\fP \- (video) * | (audio) *
.br
At compile-time libxml2 must be available.
At run-time libxml2 must be present.
Support for this module is fair.
.RS 8
interface to XML files with file listing and frame range produced by kino.
.br
Supported processing formats: audio - RAW (pass-through) PCM, video - RAW (pass-through) RGB YUV DV
.RE
.TP 4
\fByuv4mpeg\fP \- (video) YUV4MPEGx | (audio) WAVE
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
YUV from video streams produced by mjpegtools (YUV4MPEG) and RIFF WAVE pcm audio.
.br
Supported processing formats: audio - PCM, video - RGB YUV
.RE
.\" Here ends the generated import part, produced by make-module-man.sed
.RE
.IP
To see what your transcode has, do a
.nf
.B ls -1 `tcmodinfo -p`/import*.so
.fi
.IP
It is possible to pass option strings to import modules like to filter modules.
The average user does not this feature and not many modules support it. The syntax is
.B  \-x vmod=options,amod=options
.br
Example
.nf
  \-x rawlist=uyvy,null
.fi
.br
To tell the rawlist import module (which reads images from a list of files) the
colour space of the images.

.TP
.B \-y \fIvmod\fP[\fI,amod\fP]
video[,audio] export modules [null].  If omitted, transcode will encode to
the \fInull\fP module. A full-blown transcode installation has the following
export modules:
.RS
.\" Here starts the generated export part, produced by make-module-man.sed
.TP 4
\fBac3\fP \- (video) null | (audio) ac3
.br
This module has no compile-time dependencies.
At run-time ffmpeg must be present.
Support for this module is good.
.RS 8
Encodes audio (raw PCM) to AC3 via the ffmpeg binary.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBaf6\fP \- (video) Win32 dll | (audio) MPEG/AC3/PCM
.br
At compile-time libavifile must be available.
At run-time libavifile and win32codecs must be present.
Support for this module is good.
.RS 8
Interface to the avifile library which allows the use of win32codec on the linux-x86 platform.
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RGB YUV
.RE
.TP 4
\fBdivx5\fP \- (video) DivX 5.xx | (audio) MPEG/AC3/PCM
.br
At compile-time libmp3lame (only for MPEG audio layer III) must be available.
At run-time divx4linux (new) and libdivxencore.so must be present.
Support for this module is good.
.RS 8
Encodes MPEG4 video using the closed-source binaries from divx.com to an AVI container.
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RGB YUV
.RE
.TP 4
\fBdv\fP \- (video) Digital Video | (audio) MPEG/AC3/PCM
.br
At compile-time libdv and libmp3lame (only for MPEG audio layer III) must be available.
At run-time libdv must be present.
Support for this module is good.
.RS 8
Encodes DV into an AVI container. DV is a codec developed by Sony and is often used in digital camcorders.
.br
Supported processing formats: audio - PCM AC3, video - RGB YUV
.RE
.TP 4
\fBdvraw\fP \- (video) Digital Video | (audio) PCM
.br
At compile-time libdv must be available.
At run-time libdv must be present.
Support for this module is good.
.RS 8
Encodes DV into a DV file. DV is a codec developed by Sony and is often used in digital camcorders. A raw DV file can be played back into the camcorder.
.br
Supported processing formats: audio - PCM, video - RAW (pass-through) RGB YUV YUV422
.RE
.TP 4
\fBffmpeg\fP \- (video) * | (audio) MPEG/AC3/PCM
.br
At compile-time libmp3lame (only for MPEG audio layer III) must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Encodes many different formats to both AVI and raw. Supported are mpeg1video, mpeg2video, mpeg4, mjpeg, h263, h263p, wmv1, wmv2, rv10, msmpeg4, msmpeg4v2, huffyuv and dvvideo.
.br
Supported processing formats: audio RAW (pass-through) PCM AC3, video - RGB YUV YUV422
.RE
.TP 4
\fBim\fP \- (video) * | (audio) MPEG/AC3/PCM
.br
At compile-time libImageMagick must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Encodes image sequences by using the ImageMagick library. ImageMagick is able to handle a lot of different image formats such as png, jpg, miff, tiff, etc. Use -F to select the desired format.
.br
Supported processing formats: audio - RAW (pass-through) PCM, video - RGB YUV
.RE
.TP 4
\fBjpg\fP \- (video) * | (audio) MPEG/AC3/PCM
.br
At compile-time libjpeg must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Encodes jpg image sequences using libjpeg. Faster than ImageMagick. Use -F to select the compression quality.
.br
Supported processing formats: audio - RAW (pass-through) PCM, video - RGB YUV
.RE
.TP 4
\fBlame\fP \- (audio) MPEG 1/2
.br
At compile-time libmp3lame (only for MPEG audio layer III) must be available.
At run-time lame and sox must be present.
Support for this module is good.
.RS 8
An audio-only encoder which drives the lame binary. The tool sox is used to do resampling if required. Encodes to a MP3 file.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBlzo\fP \- (video) LZO real-time compression | (audio) MPEG/AC3/PCM
.br
At compile-time liblzo and libmp3lame (only for MPEG audio layer III) must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Encodes video using a loss-less real-time LZO codec. This codec is a homegrown invention of transcode and is intended as an intermediate storage format. MPlayer can playback LZO-based AVI files as well.
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RAW (pass-through) RGB YUV DV
.RE
.TP 4
\fBmov\fP \- (video) * | (audio) *
.br
At compile-time libquicktime must be available.
At run-time libquicktime must be present.
Support for this module is fair.
.RS 8
Interface to the quicktime library.
.br
Supported processing formats: audio - PCM, video - RAW (pass-through) RGB YUV YUV422 YUY2
.RE
.TP 4
\fBmp2\fP \- (video) null | (audio) MPEG 1/2
.br
This module has no compile-time dependencies.
At run-time ffmpeg and sox must be present.
Support for this module is good.
.RS 8
Encodes audio (raw PCM) to MPEG 1 Layer 2 audio aka mp2. Additionaly it can change the speed of the audio stream by a factor you can specify. See docs/export_mp2.txt.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBmp2enc\fP \- (audio) MPEG 1/2
.br
At compile-time mjpegtools must be available.
At run-time mp2enc must be present.
Support for this module is good.
.RS 8
Drives the mp2enc binary and writes an MP2 (MPEG1-Layer2) file. Useful for when encoding to SVCD to be multiplexed with mplex after encoding.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBmpeg2enc\fP \- (video) MPEG 1/2
.br
At compile-time mjpegtools must be available.
At run-time mpeg2enc must be present.
Support for this module is good.
.RS 8
Drives the mpeg2enc binary. mpeg2enc is a very feature rich MPEG encoder, have a look at its manpage. Encodes generic mpeg1, VCD, SVCD, MPEG2 and DVD type video.
.br
Supported processing formats: audio - none, video - RGB YUV
.RE
.TP 4
\fBnull\fP \- (video) null | (audio) null
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Data sink. Does nothing else than discarding data.
.br
Supported processing formats: audio - none, video - none
.RE
.TP 4
\fBogg\fP \- (video) null | (audio) ogg
.br
This module has no compile-time dependencies.
At run-time oggenc must be present.
Support for this module is good.
.RS 8
Drives the oggenc binary. Encodes an Ogg/Vorbis file. Resamples.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBppm\fP \- (video) PPM/PGM | (audio) MPEG/AC3/PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Writes an image sequence of PGM or PPM files. PPM is an old format and there are several tools around to manipulate such files.
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RGB YUV
.RE
.TP 4
\fBpvm\fP \- (video) * | (audio) *
.br
At compile-time libpvm3 must be available.
At run-time pvm must be present.
Support for this module is good.
.RS 8
Meta module. It allows transcode to be used in a PVM cluster. See docs/export_pvm.txt
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RAW (pass-through) RGB YUV DV YUV422 YUY2
.RE
.TP 4
\fBraw\fP \- (video) * | (audio) MPEG/AC3/PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Can write uncompressed streams to an AVI file as well as raw mpeg2 files in pass-through mode. The image format for uncompressed streams can be selected with -F (use -F help to see available formats).
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RAW (pass-through) RGB YUV DV YUV422
.RE
.TP 4
\fBtoolame\fP \- (audio) MPEG 1/2
.br
This module has no compile-time dependencies.
At run-time toolame and sox must be present.
Support for this module is good.
.RS 8
Drives the toolame binary to create MP2 audio tracks. Sox is used for resampling if requested.
.br
Supported processing formats: audio - PCM, video - none
.RE
.TP 4
\fBwav\fP \- (audio) WAVE PCM
.br
This module has no compile-time dependencies.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Creates WAVE PCM files with interleaved audio for stereo.
.br
Supported processing formats: audio - PCM, video - RAW (pass-through) RGB YUV
.RE
.TP 4
\fBxvid4\fP \- (video) XviD 1.0.x series (aka API 4.0) | (audio) MPEG/AC3/PCM
.br
At compile-time libmp3lame (only for MPEG audio layer III) must be available.
At run-time libxvidcore.so.4 must be present.
Support for this module is good.
.RS 8
Encodes MPEG4 video using the library available from xvid.org. Check out the library from xvidcvs using cvs -d :pserver:anonymous@cvs.xvid.org:/xvid co -rdev-api-4 xvidcore. There is also a tool available to create configuration files for this xvid version at http://zebra.fh-weingarten.de/transcode/xvid4conf. The output can either be an AVI file or a MPEG4 elementary stream (with -F raw).
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RGB YUV YUV422
.RE
.TP 4
\fByuv4mpeg\fP \- (video) YUV4MPEG2 | (audio) MPEG/AC3/PCM
.br
At compile-time mjpegtools must be available.
This module has no run-time dependencies.
Support for this module is good.
.RS 8
Writes the uncompressed raw YUV data in a YUV4MPEG format as used by the lav* and mjpeg* tools.
.br
Supported processing formats: audio - RAW (pass-through) PCM AC3, video - RGB YUV
.RE
.\" Here ends the generated export part, produced by make-module-man.sed
.RE
.IP
To see what your transcode has, do a
.br
.nf
.B ls -1 `tcmodinfo -p`/export*.so
.fi
.IP
It is possible to pass option strings to export modules like to filter modules.
The syntax is
.nf
.B  \-y vmod=options,amod=options
.fi
.TP
.B \-z
flip video frame upside down [off].

.TP
.B \-\-accel \fItype\fP
enforce experimental IA32 acceleration for type [autodetect]. \fItype\fP may be one of
.RS
.TP 8
.I C
No acceleration
.TP
.I ia32asm
plain x86 assembly
.TP
.I mmx
.TP
.I 3dnow
.TP
.I sse
.TP
.I sse2
.RE

.TP
.B \-\-avi_limit \fIN\fP
split/rotate output AVI file after N MB [2048].

.TP
.B \-\-avi_comments \fIF\fP
Read AVI header comments from file \fIF\fP [off].
.br
The AVI file format supports so-called tomb-stone data. It can be
used to write annotations into the AVI file.

See the file \fBdocs/avi_comments.txt\fP for a sample input file with all tags.
When the file is read, empty lines and lines
starting with '#' are ignored.
The syntax is: "TAG<space>STRING". The order of the tags does not
matter. If a tag has no string following it, it is ignored. That
means, you can use the file docs/avi_comments.txt as input and only fill out
the fields you want.

A very simple example is:
.nf
 ----------------snip----------------
 INAM My 1st Birthday
 ISBJ My first steps!
 IART My proud family
 ----------------snip----------------
.fi
Keep in mind that there is no endless space in the AVI header,
most likely its around 1000 bytes.

.TP
.B \-\-zoom_filter \fIstring\fP
use filter string for video resampling -Z [Lanczos3]
.br
The following filters are available:
.RS 8
.TP
Bell
.TP
Box
.TP
Lanczos3 (default)
.TP
Mitchell
.TP
Hermite
.TP
B_spline
.TP
Triangle
.RE

.TP
.B \-\-cluster_percentage
use percentage mode for cluster encoding -W [off]

.TP
.B \-\-cluster_chunks \fIa-b\fP
process chunk range instead of selected chunk [off]

.TP
.B \-\-export_asr \fIC\fP
set export aspect ratio code \fIC\fP [as input]
Valid codes for \fIC\fP are:
.RS 8
.TP
.I 1
1:1
.TP
.I 2
4:3
.TP
.I 3
16:9
.TP
.I 4
2.21:1
.RE

.TP
.B \-\-export_prof \fIS\fP
Select an export profile {vcd, svcd, xvcd, dvd} [-pal|-ntsc|-secam]
.br
Default is no profile.

If you set this meta option to one of the values below, transcode will adjust
some internal paramaters as well as geometry and clipping. If no export modules
are specified, mpeg2enc for video and mp2enc for audio are used when compiled
with mjpegtools support.

Valid values for \fIS\fP are e.g. vcd, vcd-pal, vcd-ntsc, svcd, svcd-pal, ...

xvcd profile is equal to svcd except that it allows for up to 9000 Kbps video
bitrate (default is 5000) and arbitrary audio samplerate.

When one of the above is used, transcode will calculate the needed clipping and
resizing values for you based on the import and export aspect ratio. This is
especially handy if you want to encode a 16:9 DVD into a 4:3 SVCD for example.
Transcode internally then sets --pre_clip to add the black bars ("letterboxing").

If you use "vcd" instead of "vcd-pal" or "vcd-ntsc", transcode will make an
educated guess if PAL or NTSC vcd is wanted. The same is true for the other
profiles. When the input file has no aspect ratio information at all, transcode
guesses it based on the import frame sizes. You can set the import aspect ratio
by giving --import_asr CODE.

Examples (assume input is a 16:9 coded file at 720x576 (PAL)):

.nf
   --export_prof svcd      clip top/bot -96; resizes to 480x576
   --export_prof vcd-ntsc  clip top/bot -96; resizes to 352x240
.fi

This enables simpilified commandlines where transcode tries to set sensible
values for mpeg export. When you don't specify an export module with -y,
mpeg2enc will be used.

.nf
   transcode -i vob/ --export_prof svcd -Z fast -o test
.fi

The ffmpeg export module `-y ffmpeg' does support profiles as well. The module
tries to be smart and sets internal ffmpeg parameters which are otherwise quite
tricky to find out. Usage is similar to the above

.nf
   transcode -i vob/ --export_prof dvd -y ffmpeg -o test -m test.ac3
   tcmplex -m d -i test.m2v -p test.ac3 -o test.mpg
.fi

.TP
.B \-\-export_par \fIC\fP[,\fIN\fP]
set export pixel aspect ratio to \fIC\fP[,\fIN\fP]
.br
To encode anamorphic material, transcode can encode the target pixel aspect
ratio into the file. This is NOT the actual aspect ratio of the image, but only
the amount by which every single pixel is stretched when played with an
aspect ratio aware application, like mplayer.

To encode at non standard aspect ratios, set both \fIC\fP and \fIN\fP
E.g. to make every pixel twice as high as it's wide (e.g. to scale back to
normal size after deinterlacing by dropping every second line).

If \fIC\fP and \fIN\fP are specified, the value set for \fIC\fP does give the
pixel aspect ratio of the width and \fIN\fP the one for the height
If only \fIC\fP is specified, the table below applies.
.RS
.TP 4
Valid codes for \fIC\fP are
.TP
.I 1
1:1	No stretching
.TP
.I 2
12:11	5:4 image to 4:3  (ex: 720x576 ->  768x576)
.TP
.I 3
10:11	3:2 image to 4:3  (ex: 720x480 ->  640x480)
.TP
.I 4
16:11	5:4 image to 16:9 (ex: 720x576 -> 1024x576)
.TP
.I 5
40:33	3:2 image to 16:9 (ex: 720x480 ->  872x480)
.RE

.TP
.B \-\-import_asr \fIC\fP
set import aspect ratio code \fIC\fP [autoprobed]
.RS
.TP 4
Valid codes for \fIC\fP are
.TP
.I 1
1:1
.TP
.I 2
4:3
.TP
.I 3
16:9
.TP
.I 4
2.21:1
.RE

.TP
.B \-\-keep_asr
try to keep aspect ratio (only with -Z) [off]
.RS
The \fB\-\-keep_asr\fP options changes the meaning of \fB-Z\fP. It tries to
fit the video into a framesize specified by \fB-Z\fP by keeping the
\fIoriginal\fP aspect ratio.
.nf
+----------------+                            +---480-----+
|                |                            | black     |
|720x306 = 2.35:1| -> -Z 480x480 --keep_asr ->|-----------4
|                |                            | 480x204   8
+----------------+                            |-----------0
                                              | black     |
                                              +-----------+
.fi
Consider \fB--keep_asr\fP a wrapper for calculating \fB-Y\fP options and
\fB-Z\fP options
.RE

.TP
.B \-\-mplayer_probe
use external mplayer binary to probe stream [off]
.br
Default is to use internal probing code. Usage of this option is
recommended ONLY together with mplayer import modules (-x mplayer).

.TP
.B \-\-divx_quant \fImin,max\fP
divx encoder min/max quantizer [2,31]

.TP
.B \-\-divx_rc \fIp\fP,\fIrp\fP,\fIrr\fP
divx encoder rate control parameter [2000,10,20]

.TP
.B \-\-divx_vbv_prof \fIN\fP
divx5 encoder VBV profile (0=free-5=hiqhq) [3]
.br
Sets a predefined profile for the Video Bitrate Verifier. If \fIN\fP is set to
zero, no profile is applied and the user specified values from
\fB\-\-divx_vbv\fP are used.
.RS
.TP 4
Valid profiles
.TP
.I 0
Free/No profile	( Use supplied values )
.TP
.I 1
Handheld	( 320, 16, 3072 )
.TP
.I 2
Portable	( 1920, 64, 12288 )
.TP
.I 3
Home Theatre	( 10000, 192, 36864 )
.TP
.I 4
High Definition	( 20000, 384, 73728 )
.RE

.TP
.B \-\-divx_vbv \fIbr\fP,\fIsz\fP,\fIoc\fP
divx5 encoder VBV params (bitrate,size,occup.) [10000,192,36864]
.br
These parameters are normally set through the profile parameter
\fB\-\-divx_vbv_prof\fP. Do not mess with theses value unless you are absolutely
sure of what you are doing. Transcode internally multiplicates vbv_bitrate with
400, vbv_size with 16384 and vbv_occupancy with 64 to ensure the supplied
values are multiples of what the encoder library wants.
.TP
.B \-\-export_fps \fIrate\fP[,\fIfrc\fP]
set export frame rate (and code) [as input].Valid values
for \fIfrc\fP are
.RS
.TP 4
frc	rate
.TP
.I 1
23.976	(24000/1001.0)
.TP
.I 2
24
.TP
.I 3
25
.TP
.I 4
29.970	(30000/1001.0)
.TP
.I 5
30
.TP
.I 6
50
.TP
.I 7
59.940	(2 * 29.970)
.TP
.I 8
60
.TP
.I 9
1
.TP
.I 10
5
.TP
.I 11
10
.TP
.I 12
12
.TP
.I 13
15
.RE

.TP
.B \-\-export_frc \fIF\fP
set export frame rate code \fIF\fP [as input]
.br
obsolete, use --export_fps 0,F

.TP
.B \-\-hard_fps
disable smooth dropping (for variable fps clips) [off]
.br
see /docs/framerate.txt for more information.

.TP
.B \-\-pulldown
set MPEG 3:2 pulldown flags on export [off]

.TP
.B \-\-antialias_para \fIw,b\fP
center pixel weight, xy-bias [0.333,0.500]

.TP
.B \-\-no_audio_adjust
disable internal audio frame sample adjustment [off]

.TP
.B \-\-no_bitreservoir
disable lame bitreservoir for MP3 encoding [off]

.TP
.B \-\-config_dir \fIdir\fP
Assume config files are in this \fIdir\fP
.br
This only affects the -y ffmpeg and -y xvid4 modules. It gives the path
where the modules search for their configuration.

.TP
.B \-\-lame_preset \fIname\fP[\fI,fast\fP]
use lame preset with \fIname\fP. [off]
.br
Lame features some built-in presets. Those presets are designed to provide the
highest possible quality.
They have for the most part been subject to and tuned via rigorous listening
tests to verify and achieve this objective. These are continually updated to
coincide with the latest developments that occur and as a result should provide
you with nearly the best quality currently possible from LAME.
.br
Any of those VBR presets can also be used in fast mode,
using the new vbr algorithm. This mode is faster, but its
quality could be a little lower. To enable the fast mode,
append "\fI,fast\fP"
.PP
.RS
.TP 13
.I <N kbps>
Using this preset will usually give you good quality at a specified bitrate.
Depending on the bitrate entered, this preset will determine the optimal
settings for that particular situation. While this approach works, it is not
nearly as flexible as VBR, and usually will not reach the same quality level as
VBR at higher bitrates. ABR.
.TP
.I medium
This preset should provide near transparency to most people on most music. The
resulting bitrate should be in the 150-180kbps range, according to music
complexity. VBR.
.TP
.I standard
This preset should generally be transparent to most people on most music and is
already quite high in quality.  The resulting bitrate should be in the
170-210kbps range, according to music complexity. VBR.
.TP
.I extreme
If you have extremely good hearing and similar equipment, this preset will
provide slightly higher quality than the "standard" mode.  The resulting
bitrate should be in the 200-240kbps range, according to music complexity. VBR.
.TP
.I insane
This preset will usually be overkill for most people and most situations, but
if you must have the absolute highest quality with no regard to filesize, this
is the way to go. This preset is the highest preset quality available.  320kbps
CBR.
.TP
(taken from http://www.mp3dev.org/mp3/doc/html/presets.html)
.RE

.TP
.B \-\-av_fine_ms \fIt\fP
AV fine-tuning shift \fIt\fP in millisecs [autodetect]
.br
also see -D.

.TP
.B \-\-nav_seek \fIfile\fP
use VOB or AVI navigation file [off].
.br
Generate a nav file with tcdemux -W >nav_log for VOB files or with aviindex(1)
for AVI files.

.TP
.B \-\-psu_mode
process VOB in PSU, -o is a filemask incl. %d [off]. PSU means Program
Stream Unit and this mode is useful for (mostly) NTSC DVDs which have
several program stream units.

.TP
.B \-\-psu_chunks \fIa-b\fP
process only selected units \fIa-b\fP for PSU mode [all]

.TP
.B \-\-no_split
encode to single file in chapter/psu/directory mode [off]
.br
If you don't give this option, you'll end up with several files in one of the
above mentioned modes. It is still possible to merge them with avimerge(1).

.TP
.B \-\-pre_clip t[,l[,b[,r]]]
select initial frame region by clipping border [off]

.TP
.B \-\-post_clip t[,l[,b[,r]]]
select final frame region by clipping border [off]

.TP
.B \-\-a52_drc_off
disable liba52 dynamic range compression [enabled]
.br
If you dont specify this option, liba52 will provide the default behaviour, which is to
apply the full dynamic range compression as specified in the A/52 stream. This
basically makes the loud sounds softer, and the soft sounds louder, so you can
more easily listen to the stream in a noisy environment without disturbing
anyone.

If you let it enabled this this will totally disable the dynamic range
compression and provide a playback more adapted to a movie theater or a
listening room.

.TP
.B \-\-a52_demux
demux AC3/A52 to separate channels [off]

.TP
.B \-\-a52_dolby_off
disable liba52 dolby surround [enabled]
.br
selects whether the output is plain stereo (if the option is set) or if
it is Dolby Pro Logic - also called Dolby surround or 3:1 - downmix (if
the option is not used).

.TP
.B \-\-color \fIN\fP
level of color in transcodes output [1]
.br
Colorful output can be disabled by setting \fIN\fP to \fI0\fP. It will be
automatically disabled if the output of transcode is a file or a pipe.

.TP
.B \-\-dir_mode \fIbase\fP
process directory contents to base-%03d.avi [off]

.TP
.B \-\-frame_interval \fIN\fP
select only every \fIN\fPth frame to be exported [1]

.TP
.B \-\-encode_fields \fIC\fP
enable field based encoding (if supported) [off]
.br
This option takes an argument if given to denote the order of fields. If the
option is not given, it defaults to progressive (do not assume the picture is
interlaced)
.RS
.IP
Valid codes for \fIC\fP are:
.TP 4
.I p
progressive (default)
.TP
.I t
top-field first
.TP
.I b
bottom-field first
.RE

.TP
.B \-\-dv_yuy2_mode, \-\-dv_yv12_mode
Indicates that libdv decodes Digital Video frames in YUY2 (packed) or YV12
(planar) mode, respectively. Normally transcode figures out the correct
mode automatically, but if you try to transcode PAL DV files and the
results look strange, try one of these options.

.TP
.B \-\-write_pid \fIfile\fP
write pid of signal thread to \fIfile\fP [off]
Enables you to terminate transcode cleanly by sending a SIGINT (2) to the pid
in \fIfile\fP. Please note \fIfile\fP will be overwritten. Usage example
.RS 8

.nf
$ transcode ... \-\-write_pid /tmp/transcode.pid &
$ kill -2 `cat /tmp/transcode.pid`
.fi
.RE

.TP
.B \-\-nice \fIN\fP
set niceness to \fIN\fP [off]
.br
The option \-\-nice which renices transcode to the given positive or
negative value. \-10 sets a high priority; +10 a low priority.
This might be useful for cluster mode.

.TP
.B \-\-progress_meter \fIN\fP
select type of progress meter [1]
.br
Selects the type of progress message printed by transcode on standard output:
    0: no progress meter
    1: standard progress meter
    2: raw progress data
Transcode defaults to type 1 if standard output is a terminal, type 0 (no
progress meter) if standard output is a file or pipe.  Scripts that need
progress data should use type 2, since the format of type 1 is subject to
change without notice.

.TP
.B \-\-progress_rate \fIN\fP
print progress every \fIN\fP frames [1]
.br
Controls how frequently the status message is printed (every \fIN\fP frames).

.TP
.B \-\-socket \fIFILE\fP
Open a socket to accept commands while running. See \fBtcmodinfo(1)\fP and
/docs/filter-socket.txt for more information about the protocol.

.SH FILTERS
The syntax for filter options is simple. A filter is specified with
.RS 8
.nf
\-J filter=\fIoptionstring\fP
.fi
.RE
The optionstring can contain multiple options which are separated by colons \`:\'
.RS 8
.nf
\-J filter=\fIoption1\fP:\fIoption2\fP:\fIoption3\fP
.fi
.RE
An option can have an argument or non (bool). For options with an argument, the
format in which the argument has to be given to the option is specified in a
printf(1) like string. The most common case is `%d' which simply means a number. The argument has to be seperated from the option by a \`=\'.
.RS 8
.nf
\-J filter=\fIbool1\fP:\fIoption1\fP=\fI15\fP:\fIoption2\fP=\fI20x30\fP
.fi
.RE
Most filters try to do the right thing with the default options. You should
play with various parameters if you are not satisfied with the default
behaviour. If you have no idea what a filter does, its very likely that you
don't need it.

If a filter takes (for eg.) a filename as an argument, make sure that the
filename does not contain a `:' or a `='. Its a limitation of the parser. A
comma `,' is possible but must be extra quoted. For the text filter that is
.RS 8
.nf
\-J text=string="Hello\\, World"
.fi
.RE
.\" Here starts the generated filter part, produced by make-filter-man.sh
.TP 4
\fB29to23\fP - \fBframe rate conversion filter (interpolating 29 to 23)\fP
\fB29to23\fP was written by Max Alekseyev, Tilmann Bitterberg. The version documented here is v0.3 (2003-07-18). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.TP 4
\fB32detect\fP - \fB3:2 pulldown / interlace detection plugin\fP
\fB32detect\fP was written by Thomas. The version documented here is v0.2.4 (2003-07-22). This is a video filter. It can handle RGB and YUV mode. It supports multiple instances and can run as a pre-processing and/or as a post-processing filter.
.IP
.RS
\(bu
.I threshold
= \fI%d\fP  [default \fI9\fP]
.RS 3
Interlace detection threshold
.RE
\(bu
.I chromathres
= \fI%d\fP  [default \fI4\fP]
.RS 3
Interlace detection chroma threshold
.RE
\(bu
.I equal
= \fI%d\fP  [default \fI10\fP]
.RS 3
threshold for equal colors
.RE
\(bu
.I chromaeq
= \fI%d\fP  [default \fI5\fP]
.RS 3
threshold for equal chroma
.RE
\(bu
.I diff
= \fI%d\fP  [default \fI30\fP]
.RS 3
threshold for different colors
.RE
\(bu
.I chromadi
= \fI%d\fP  [default \fI15\fP]
.RS 3
threshold for different chroma
.RE
\(bu
.I force_mode
= \fI%d\fP  [default \fI0\fP]
.RS 3
set internal force de-interlace flag with mode -I N
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI1\fP]
.RS 3
run as pre filter
.RE
\(bu
.I verbose
(bool)
.RS 3
show results
.RE
.IP
This filter checks for interlaced video frames.
Subsequent de-interlacing with transcode can be enforced with 'force_mode' option
.RE
.TP 4
\fB32drop\fP - \fB3:2 inverse telecine removal plugin\fP
\fB32drop\fP was written by Thomas Oestreich. The version documented here is v0.4 (2003-02-01). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.TP 4
\fBaclip\fP - \fBgenerate audio clips from source\fP
\fBaclip\fP was written by Thomas Oestreich. The version documented here is v0.1.1 (2003-09-04). This is a audio filter. It is a pre-processing only filter.
.IP
.RS
\(bu
.I level
= \fI%d\fP  [default \fI10\fP]
.RS 3
The audio must be under this level to be skipped
.RE
\(bu
.I range
= \fI%d\fP  [default \fI25\fP]
.RS 3
Number of samples over level will be keyframes
.RE
.RE
.TP 4
\fBastat\fP - \fBaudio statistics filter plugin\fP
\fBastat\fP was written by Thomas Oestreich. The version documented here is v0.1.3 (2003-09-04). This is a audio filter. It is a pre-processing only filter.
.IP
.RS
\(bu
.I file
= \fI%s\fP
.RS 3
File to save the calculated volume rescale number to
.RE
.RE
.RE
.TP 4
\fBcompare\fP - \fBcompare with other image to find a pattern\fP
\fBcompare\fP was written by Antonio Beamud. The version documented here is v0.1.2 (2003-08-29). This is a video filter. It can handle RGB and YUV mode. It supports multiple instances. It is a post-processing only filter.
.IP
.RS
\(bu
.I pattern
= \fI%s\fP
.RS 3
Pattern image file path
.RE
\(bu
.I results
= \fI%s\fP
.RS 3
Results file path
.RE
\(bu
.I delta
= \fI%f\fP  [default \fI45.000000\fP]
.RS 3
Delta error
.RE
.IP
Generate a file in with information about the times, frame, etc the pattern
defined in the image parameter is observed.
.RE
.IP
The format of the command file is framenumber followed by at least one whitespace followed
by the command followed by at least one whitespace followed by arguments for the command.
Empty lines and lines starting with a `#' are ignored. The frame numbers must be sorted ascending.

      # Example file
      # At frame 10 load the smooth filter
      10 load smooth
      # reconfigure at 20
      20 configure smooth=strength=0.9
      99 disable smooth


.RE
.TP 4
\fBcpaudio\fP - \fBcopy one audio channel to the other channel filter plugin\fP
\fBcpaudio\fP was written by William H Wittig. The version documented here is v0.1 (2003-04-30). This is a audio filter. It is a post-processing only filter.
.IP
.RS
\(bu
.I source
= \fI%c\fP  [default \fIl\fP]
.RS 3
Source channel (l=left, r=right)
.RE
.IP
Copies audio from one channel to another
.RE
.TP 4
\fBdecimate\fP - \fBNTSC decimation plugin\fP
\fBdecimate\fP was written by Thanassis Tsiodras. The version documented here is v0.4 (2003-04-22). This is a video filter. It can handle YUV mode only. It is a post-processing only filter.
.IP
.RS
\(bu
.I verbose
(bool)
.RS 3
print verbose information
.RE
.IP
see /docs/README.Inverse.Telecine.txt
.RE
.TP 4
\fBdenoise3d\fP - \fBHigh speed 3D Denoiser\fP
\fBdenoise3d\fP was written by Daniel Moreno & A'rpi. The version documented here is v1.0.6 (2003-12-20). This is a video filter. It can handle YUV mode only. It supports multiple instances. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
\(bu
.I luma
= \fI%f\fP  [default \fI4.000000\fP]
.RS 3
spatial luma strength
.RE
\(bu
.I chroma
= \fI%f\fP  [default \fI3.000000\fP]
.RS 3
spatial chroma strength
.RE
\(bu
.I luma_strength
= \fI%f\fP  [default \fI6.000000\fP]
.RS 3
temporal luma strength
.RE
\(bu
.I chroma_strength
= \fI%f\fP  [default \fI4.000000\fP]
.RS 3
temporal chroma strength
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI0\fP]
.RS 3
run as a pre filter
.RE
.IP
What:
The denoise3d filter from mplayer (sibling of hqdn3d). Works very crude and
simple but also very fast. In fact it is even faster than the original from
mplayer as I managed to tweak some things (a.o. zero frame copying).

Who:
Everyone who wants to have their captured frames thoroughly denoised (i.e. who
want to encode to mpeg or mjpeg) but do not have enough processing power to
real-time encode AND use hqdn3d (better quality but a lot slower) or dnr (yet
slower), not to mention the other denoisers that are even slower. Quality is
really good for static scenes (if fed with the right parameters), moving
objects may show a little ghost-image (also depends on parameters) though. Your
milage may vary.

How:
Parameters are the same as the hqdn3d module, although in practice you'll not
end up with exactly the same values. Just experiment.  Particular for this
version of the filter is that if you supply -1 to either component's parameters
(luma/chroma), that component will not have the filter applied to. If you're
still short on CPU cycles, try disabling the luma filter, this will not make
much difference in the effectiveness of the filter!
.RE
.TP 4
\fBdetectclipping\fP - \fBdetect clipping parameters (-j or -Y)\fP
\fBdetectclipping\fP was written by Tilmann Bitterberg, A'rpi. The version documented here is v0.1.0 (2003-11-01). This is a video filter. It can handle RGB and YUV mode. It supports multiple instances and can run as a pre-processing and/or as a post-processing filter.
.IP
.RS
\(bu
.I range
= \fI%u-%u/%d\fP  [default \fI0-4294967295/1\fP]
.RS 3
apply filter to [start-end]/step frames
.RE
\(bu
.I limit
= \fI%d\fP  [default \fI24\fP]
.RS 3
the sum of a line must be below this limit to be considered as black
.RE
\(bu
.I post
(bool)
.RS 3
run as a POST filter (calc -Y instead of the default -j)
.RE
.IP
Detect black regions on top, bottom, left and right of an image.  It is suggested that the filter is run for around 100 frames.  It will print its detected parameters every frame. If you don't notice any change in the printout for a while, the filter probably won't find any other values.  The filter converges, meaning it will learn.
.RE
.TP 4
\fBdetectsilence\fP - \fBaudio silence detection with tcmp3cut commandline generation\fP
\fBdetectsilence\fP was written by Tilmann Bitterberg. The version documented here is v0.0.1 (2003-07-26). This is a audio filter. It is a pre-processing only filter.
.TP 4
\fBdivxkey\fP - \fBcheck for DivX 4.xx / OpenDivX / DivX;-) keyframe\fP
\fBdivxkey\fP was written by Thomas Oestreich. The version documented here is v0.1 (2002-01-15). This is a video filter. It is a pre-processing only filter.
.TP 4
\fBdnr\fP - \fBdynamic noise reduction\fP
\fBdnr\fP was written by Gerhard Monzel. The version documented here is v0.2 (2003-01-21). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I lt
= \fI%d\fP  [default \fI10\fP]
.RS 3
Threshold to blend luma/red
.RE
\(bu
.I ll
= \fI%d\fP  [default \fI4\fP]
.RS 3
Threshold to lock luma/red
.RE
\(bu
.I ct
= \fI%d\fP  [default \fI16\fP]
.RS 3
Threshold to blend croma/green+blue
.RE
\(bu
.I cl
= \fI%d\fP  [default \fI8\fP]
.RS 3
Threshold to lock croma/green+blue
.RE
\(bu
.I sc
= \fI%d\fP  [default \fI30\fP]
.RS 3
Percentage of picture difference (scene change)
.RE
.IP
see /docs/filter_dnr.txt (german only)
.RE
.TP 4
\fBdoublefps\fP - \fBdouble frame rate by deinterlacing fields into frames\fP
\fBdoublefps\fP was written by Andrew Church. The version documented here is v1.1 (2006-05-14). This is a video and audio filter. It can handle YUV and YUV422 modes. It is a pre-processing only filter.
.IP
.RS
\(bu
.I topfirst
= \fI%d\fP  [default \fI0\fP when height=480, else \fI1\fP]
.RS 3
Assume top field is displayed first
.RE
\(bu
.I fullheight
= \fI%d\fP  [default \fI0\fP]
.RS 3
Output full-height frames
.RE

Doubles the frame rate of interlaced video by separating each field
into a separate frame.  The fields can either be left as is (giving a
progessive video with half the height of the original) or re-interlaced
into their original height (at the doubled frame rate) for the
application of a separate deinterlacing filter.

Note that due to transcode limitations, it is currently necessary to use
the -Z option to specify the output frame size when using half-height mode
(this does not slow the program down if no actual zooming is done).
.RE
.TP 4
\fBextsub\fP - \fBDVD subtitle overlay plugin\fP
\fBextsub\fP was written by Thomas Oestreich. The version documented here is 0.3.5 (2003-10-15). This is a video filter. It can handle RGB and YUV mode. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
\(bu
.I track
= \fI%d\fP  [default \fI0\fP]
.RS 3
Subtitle track to render
.RE
\(bu
.I vertshift
= \fI%d\fP  [default \fI0\fP]
.RS 3
offset of subtitle with respect to bottom of frame in rows
.RE
\(bu
.I timeshift
= \fI%d\fP  [default \fI0\fP]
.RS 3
global display start time correction in msec
.RE
\(bu
.I antialias
= \fI%d\fP  [default \fI1\fP]
.RS 3
anti-aliasing the rendered text (0=off,1=on)
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI1\fP]
.RS 3
Run as a pre filter
.RE
\(bu
.I color1
= \fI%d\fP  [default \fI0\fP]
.RS 3
Make a subtitle color visible with given intensity
.RE
\(bu
.I color2
= \fI%d\fP  [default \fI0\fP]
.RS 3
Make a subtitle color visible with given intensity
.RE
\(bu
.I ca
= \fI%d\fP  [default \fI0\fP]
.RS 3
Shuffle the color assignment by choosing another subtitle color
.RE
\(bu
.I cb
= \fI%d\fP  [default \fI0\fP]
.RS 3
Shuffle the color assignment by choosing another subtitle color
.RE
.RE
.TP 4
\fBfieldanalysis\fP - \fBField analysis for detecting interlace and telecine\fP
\fBfieldanalysis\fP was written by Matthias Hopf. The version documented here is v1.0 pl1 (2004-08-13). This is a video filter. It can handle RGB,YUV and YUV422 mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I interlacediff
= \fI%f\fP  [default \fI1.1\fP]
.RS 3
Minimum temporal inter-field difference for detecting interlaced video
.RE
\(bu
.I unknowndiff
= \fI%f\fP  [default \fI1.5\fP]
.RS 3
Maximum inter-frame change vs. detail differences for neglecting interlaced video
.RE
\(bu
.I progressivediff
= \fI%f\fP  [default \fI8\fP]
.RS 3
Minimum inter-frame change vs. detail differences for detecting progressive video
.RE
\(bu
.I progressivechange
= \fI%f\fP  [default \fI0.2\fP]
.RS 3
Minimum temporal change needed for detecting progressive video
.RE
\(bu
.I changedifmore
= \fI%f\fP  [default \fI10\fP]
.RS 3
Minimum temporal change for detecting truly changed frames
.RE
\(bu
.I forcetelecinedetect
= \fI%d\fP  [default \fI0\fP]
.RS 3
Detect telecine even on non-NTSC (29.97fps) video
.RE
\(bu
.I verbose
= \fI%d\fP  [default \fI0\fP]
.RS 3
Output analysis for every frame
.RE
\(bu
.I outdiff
= \fI%d\fP  [default \fI0\fP]
.RS 3
Output internal debug frames as luminance of YUV video (see source)
.RE
.RE
.TP 4
\fBfields\fP - \fBField adjustment plugin\fP
\fBfields\fP was written by Alex Stewart. The version documented here is v0.1.1 (2003-01-21). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I flip
(bool)
.RS 3
Exchange the top field and bottom field of each frame
.RE
\(bu
.I shift
(bool)
.RS 3
Shift the video by one field
.RE
\(bu
.I flip_first
(bool)
.RS 3
Normally shifting is performed before flipping, this option reverses that
.RE
.IP
The 'fields' filter is designed to shift, reorder, and
generally rearrange independent fields of an interlaced
video input.  Input retrieved from broadcast (PAL, NTSC,
etc) video sources generally comes in an interlaced form
where each pass from top to bottom of the screen displays
every other scanline, and then the next pass displays the
lines between the lines from the first pass.  Each pass is
known as a "field" (there are generally two fields per
frame).  When this form of video is captured and manipulated
digitally, the two fields of each frame are usually merged
together into one flat (planar) image per frame.  This
usually produces reasonable results, however there are
conditions which can cause this merging to be performed
incorrectly or less-than-optimally, which is where this
filter can help.

The following options are supported for this filter
(they can be separated by colons):

  shift - Shift the video by one field (half a frame),
          changing frame boundaries appropriately.  This is
          useful if a video capture started grabbing video
          half a frame (one field) off from where frame
          boundaries were actually intended to be.

  flip  - Exchange the top field and bottom field of each
          frame.  This can be useful if the video signal was
          sent "bottom field first" (which can happen
          sometimes with PAL video sources) or other
          oddities occurred which caused the frame
          boundaries to be at the right place, but the
          scanlines to be swapped.

  flip_first
        - Normally shifting is performed before flipping if
          both are specified.  This option reverses that
          behavior.  You should not normally need to use
          this unless you have some extremely odd input
          material, it is here mainly for completeness.

  help  - Print this text.

Note: the 'shift' function may produce slight color
discrepancies if YV12 is used as the internal transcode
video format (default).  This is because YV12 does not
contain enough information to do field shifting cleanly. For
best (but slower) results, use RGB mode for field shifting.
.RE
.TP 4
\fBfps\fP - \fBconvert video frame rate, gets defaults from -f and --export_fps\fP
\fBfps\fP was written by Christopher Cramer. The version documented here is v1.1 (2004-05-01). This is a video filter. It can handle RGB and YUV mode. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
.IP
options: <input fps>:<output fps>
example: -J fps=25:29.97 will convert from PAL to NTSC
If no options are given, defaults or -f/--export_fps/--export_frc will be used.
Some examples:

	-J fps=10:5:pre		convert from 10 fps to 5 fps, preprocess
	-J fps=10:post:12	convert from 10 to 12, postprocess
	-J fps=pre=1:7:5	convert from 7 to 5, postprocess
	-J fps=9:3.1:post=-0x7	convert from 9 to 3.1, postprocess

If that last one is confusing you, remember that 0 is false and everything
else is true. Of course, octal and hexadecimal numbers are supported too.
This is intended to be backward compatible with the old format.
.RE
.TP 4
\fBhqdn3d\fP - \fBHigh Quality 3D Denoiser\fP
\fBhqdn3d\fP was written by Daniel Moreno & A'rpi. The version documented here is v1.0.2 (2003-08-15). This is a video filter. It can handle YUV mode only. It supports multiple instances. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
\(bu
.I luma
= \fI%f\fP  [default \fI4.000000\fP]
.RS 3
spatial luma strength
.RE
\(bu
.I chroma
= \fI%f\fP  [default \fI3.000000\fP]
.RS 3
spatial chroma strength
.RE
\(bu
.I luma_strength
= \fI%f\fP  [default \fI6.000000\fP]
.RS 3
temporal luma strength
.RE
\(bu
.I chroma_strength
= \fI%f\fP  [default \fI4.500000\fP]
.RS 3
temporal chroma strength
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI0\fP]
.RS 3
run as a pre filter
.RE
.IP
This filter aims to reduce image noise producing smooth images and making still images really still (This should enhance compressibility).
.RE
.TP 4
\fBinvert\fP - \fBinvert the image\fP
\fBinvert\fP was written by Tilmann Bitterberg. The version documented here is v0.1.4 (2003-10-12). This is a video filter. It can handle RGB,YUV and YUV422 mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I range
= \fI%u-%u/%d\fP  [default \fI0-4294967295/1\fP]
.RS 3
apply filter to [start-end]/step frames
.RE
.RE
.TP 4
\fBivtc\fP - \fBNTSC inverse telecine plugin\fP
\fBivtc\fP was written by Thanassis Tsiodras. The version documented here is v0.4.1 (2004-06-01). This is a video filter. It can handle YUV mode only. It is a pre-processing only filter.
.IP
.RS
\(bu
.I verbose
(bool)
.RS 3
print verbose information
.RE
\(bu
.I field
= \fI%d\fP  [default \fI0\fP]
.RS 3
which field to replace (0=top 1=bottom)
.RE
\(bu
.I magic
= \fI%d\fP  [default \fI0\fP]
.RS 3
perform magic? (0=no 1=yes)
.RE
.IP
see /docs/README.Inverse.Telecine.txt
.RE
.TP 4
\fBlevels\fP - \fBLuminosity level scaler\fP
\fBlevels\fP was written by Bryan Mayland. The version documented here is v1.0.0 (2004-06-09). This is a video filter. It can handle YUV mode only. It supports multiple instances. It is a post-processing only filter.
.IP
.RS
\(bu
.I input
= \fI%d-%d\fP  [default \fI0-255\fP]
.RS 3
input luma range (black-white)
.RE
\(bu
.I gamma
= \fI%f\fP  [default \fI1.000000\fP]
.RS 3
input luma gamma
.RE
\(bu
.I output
= \fI%d-%d\fP  [default \fI0-255\fP]
.RS 3
output luma range (black-white)
.RE
.RE
.TP 4
\fBlogo\fP - \fBrender image in videostream\fP
\fBlogo\fP was written by Tilmann Bitterberg. The version documented here is v0.10 (2003-10-16). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I file
= \fI%s\fP
.RS 3
Image filename
.RE
\(bu
.I posdef
= \fI%d\fP  [default \fI0\fP]
.RS 3
Position (0=None, 1=TopL, 2=TopR, 3=BotL, 4=BotR, 5=Center)
.RE
\(bu
.I pos
= \fI%dx%d\fP  [default \fI0x0\fP]
.RS 3
Position (0-width x 0-height)
.RE
\(bu
.I range
= \fI%u-%u\fP  [default \fI0-0\fP]
.RS 3
Restrict rendering to framerange
.RE
\(bu
.I ignoredelay
(bool)
.RS 3
Ignore delay specified in animations
.RE
\(bu
.I rgbswap
(bool)
.RS 3
Swap red/blue colors
.RE
\(bu
.I grayout
(bool)
.RS 3
YUV only: don't write Cb and Cr, makes a nice effect
.RE
\(bu
.I flip
(bool)
.RS 3
Mirror image
.RE
.IP
This filter renders an user specified image into the video.
Any image format ImageMagick can read is accepted.
Transparent images are also supported.
Image origin is at the very top left.

see /docs/filter_logo.txt
.RE
.TP 4
\fBlogoaway\fP - \fBremove an image from the video\fP
\fBlogoaway\fP was written by Thomas Wehrspann <thomas@wehrspann.de>. The version documented here is v0.5 (2004-03-07). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter. It supports multiple instances.
.IP
.RS
\(bu
.I range
= \fI%d-%d\fP  [default \fI0-4294967295\fP]
.RS 3
Frame Range
.RE
\(bu
.I pos
= \fI%dx%d\fP  [default \fI-1x-1\fP]
.RS 3
Position of logo
.RE
\(bu
.I size
= \fI%dx%d\fP  [default \fI-2x-2\fP]
.RS 3
Size of logo
.RE
\(bu
.I mode
= \fI%d\fP  [default \fI0\fP]
.RS 3
Filter Mode (0=none,1=solid,2=xy,3=shape)
.RE
\(bu
.I border
(bool)
.RS 3
Visible Border
.RE
\(bu
.I dump
(bool)
.RS 3
Dump filterarea to file
.RE
\(bu
.I xweight
= \fI%d\fP  [default \fI50\fP]
.RS 3
X-Y Weight(0%-100%)
.RE
\(bu
.I fill
= \fI%2x%2x%2x\fP  [default \fI000\fP]
.RS 3
Solid Fill Color(RGB)
.RE
\(bu
.I file
= \fI%s\fP
.RS 3
Image with alpha/shape information
.RE
.IP
This filter removes an image in a user specified area from the video.  You can
choose from different methods.

see /docs/filter_logoaway.txt
.RE
.TP 4
\fBlowpass\fP - \fBHigh and low pass filter\fP
\fBlowpass\fP was written by Tilmann Bitterberg. The version documented here is v0.1.0 (2002-02-26). This is a audio filter. It is a pre-processing only filter.
.IP
.RS
\(bu
.I taps
= \fI%d\fP  [default \fI30\fP]
.RS 3
strength (may be negative)
.RE
.RE
.TP 4
\fBmask\fP - \fBFilter through a rectangular Mask\fP
\fBmask\fP was written by Thomas Oestreich, Chad Page. The version documented here is v0.2.3 (2003-10-12). This is a video filter. It can handle RGB,YUV and YUV422 mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I lefttop
= \fI%dx%d\fP  [default \fI0x0\fP]
.RS 3
Upper left corner of the box
.RE
\(bu
.I rightbot
= \fI%dx%d\fP  [default \fI32x32\fP]
.RS 3
Lower right corner of the box
.RE
.IP
This filter applies an rectangular mask to the video.  Everything outside the mask is set to black.
.RE
.TP 4
\fBmodfps\fP - \fBplugin to modify framerate\fP
\fBmodfps\fP was written by Marrq. The version documented here is v0.10 (2003-08-18). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I mode
= \fI%d\fP  [default \fI1\fP]
.RS 3
mode of operation
.RE
\(bu
.I infps
= \fI%f\fP  [default \fI25.000000\fP]
.RS 3
Original fps
.RE
\(bu
.I infrc
= \fI%d\fP  [default \fI0\fP]
.RS 3
Original frc
.RE
\(bu
.I examine
= \fI%d\fP  [default \fI5\fP]
.RS 3
How many frames to buffer
.RE
\(bu
.I subsample
= \fI%d\fP  [default \fI32\fP]
.RS 3
How many pixels to subsample
.RE
\(bu
.I clonetype
= \fI%d\fP  [default \fI0\fP]
.RS 3
How to clone frames
.RE
\(bu
.I verbose
= \fI%d\fP  [default \fI1\fP]
.RS 3
run in verbose mode
.RE
.IP
This filter aims to allow transcode to alter the fps
of video.  While one can reduce the fps to any amount,
one can only increase the fps to at most twice the
original fps.

There are two modes of operation, buffered and unbuffered,
unbuffered is quick, but buffered, especially when dropping frames
should look better.

For most users, modfps will need either no options, or just mode=1

see /docs/README.filter.modfps
.RE
.TP 4
\fBmsharpen\fP - \fBVirtualDub's MSharpen Filter\fP
\fBmsharpen\fP was written by Donald Graft, William Hawkins. The version documented here is (1.0) (2003-07-17). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I strength
= \fI%d\fP  [default \fI100\fP]
.RS 3
How much  of the effect
.RE
\(bu
.I threshold
= \fI%d\fP  [default \fI10\fP]
.RS 3
How close a pixel must be to the brightest or dimmest pixel to be mapped
.RE
\(bu
.I highq
= \fI%d\fP  [default \fI1\fP]
.RS 3
Tradeoff speed for quality of detail detection
.RE
\(bu
.I mask
= \fI%d\fP  [default \fI0\fP]
.RS 3
Areas to be sharpened are shown in white
.RE
.IP
This plugin implements an unusual concept in spatial sharpening.
Although designed specifically for anime, it also works well with
normal video. The filter is very effective at sharpening important
edges without amplifying noise.

  * Strength 'strength' (0-255) [100]
    This is the strength of the sharpening to be applied to the edge detail areas. It is applied only to the edge detail areas as determined by the 'threshold' parameter. Strength 255 is the strongest sharpening.
  * Threshold 'threshold' (0-255) [10]
    This parameter determines what is detected as edge detail and thus sharpened. To see what edge detail areas will be sharpened, use the 'mask' parameter.
  * Mask 'mask' (0-1) [0]
    When set to true, the areas to be sharpened are shown in white against a black background. Use this to set the level of detail to be sharpened. This function also makes a basic edge detection filter.
  * HighQ 'highq' (0-1) [1]
    This parameter lets you tradeoff speed for quality of detail detection. Set it to true for the best detail detection. Set it to false for maximum speed.
.RE
.TP 4
\fBnormalize\fP - \fBVolume normalizer\fP
\fBnormalize\fP was written by pl, Tilmann Bitterberg. The version documented here is v0.1.1 (2002-06-18). This is a audio filter. It is a pre-processing only filter.
.IP
.RS
\(bu
.I smooth
= \fI%f\fP  [default \fI0.06\fP]
.RS 3
Value for smoothing ]0.0 1.0[
.RE
\(bu
.I smoothlast
= \fI%f\fP  [default \fI0.06\fP]
.RS 3
Value for smoothing last sample ]0.0, 1.0[
.RE
\(bu
.I algo
= \fI%d\fP  [default \fI1\fP]
.RS 3
Algorithm to use (1 or 2). 1=uses a 1 value memory and coefficients new=a*old+b*cur (with a+b=1).   2=uses several samples to smooth the variations (standard weighted mean on past samples)
.RE
.RE
.TP 4
\fBnull\fP - \fBdemo filter plugin; does nothing\fP
\fBnull\fP was written by Thomas Oestreich. The version documented here is v0.2 (2003-09-04). This is a video and audio filter. It can be used as a pre-processing or as a post-processing filter.
.TP 4
\fBpp\fP - \fBMplayers postprocess filters\fP
\fBpp\fP was written by Michael Niedermayer et al, Gerhard Monzel. The version documented here is v1.2.4 (2003-01-24). This is a video filter. It can handle YUV mode only. It supports multiple instances. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
\(bu
.I hb
= \fI%d:%d\fP  [default \fI64:40\fP]
.RS 3
Horizontal deblocking filter
.RE
\(bu
.I vb
= \fI%d:%d\fP  [default \fI64:40\fP]
.RS 3
Vertical deblocking filter
.RE
\(bu
.I h1
(bool)
.RS 3
Experimental h deblock filter 1
.RE
\(bu
.I v1
(bool)
.RS 3
Experimental v deblock filter 1
.RE
\(bu
.I dr
(bool)
.RS 3
Deringing filter
.RE
\(bu
.I al
(bool)
.RS 3
Automatic brightness / contrast
.RE
\(bu
.I f
(bool)
.RS 3
Stretch luminance to (0..255)
.RE
\(bu
.I lb
(bool)
.RS 3
Linear blend deinterlacer
.RE
\(bu
.I li
(bool)
.RS 3
Linear interpolating deinterlace
.RE
\(bu
.I ci
(bool)
.RS 3
Cubic interpolating deinterlacer
.RE
\(bu
.I md
(bool)
.RS 3
Median deinterlacer
.RE
\(bu
.I de
(bool)
.RS 3
Default preset (hb:a/vb:a/dr:a/al)
.RE
\(bu
.I fa
(bool)
.RS 3
Fast preset (h1:a/v1:a/dr:a/al)
.RE
\(bu
.I tn
= \fI%d:%d:%d\fP  [default \fI64:128:256\fP]
.RS 3
Temporal Noise Reducer (1<=2<=3)
.RE
\(bu
.I fq
= \fI%d\fP  [default \fI15\fP]
.RS 3
Force quantizer
.RE
\(bu
.I pre
(bool)
.RS 3
Run as a PRE filter
.RE
.RE
.TP 4
\fBpreview\fP - \fBxv/sdl/gtk preview plugin\fP
\fBpreview\fP was written by Thomas Oestreich. The version documented here is v0.1.4 (2002-10-08). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
.IP
XXX: Write me
.RE
.TP 4
\fBpv\fP - \fBxv only preview plugin\fP
\fBpv\fP was written by Thomas Oestreich, Tilmann Bitterberg. The version documented here is v0.2.3 (2004-06-01). This is a video filter. It can handle YUV and YUV422 mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I cache
= \fI%d\fP  [default \fI15\fP]
.RS 3
Number of raw frames to cache for seeking
.RE
\(bu
.I skip
= \fI%d\fP  [default \fI0\fP]
.RS 3
display only every Nth frame
.RE
\(bu
.I fullscreen
(bool)
.RS 3
Display in fullscreen mode
.RE
.IP
The filter listens to mouse and key strokes. If you click into the preview
window, the first time say near the upper left corner and the second time near
the lower right corner, transcode will draw a rectangle and will print out the
coordinates of this rectangle on stdout and the socket. See the table below for
available keys.

When you start transcode with the --socket option and the pv filter with (for
example) cache=20 you can talk to transcode and the pv filter at runtime using
the socket.

.nf
transcode -i file.avi -J pv=cache=30 --socket /tmp/sock
.fi

.RS
.TP 8
Available Commands
.TP
Key	Socket*	Effect
.TP
.I RET
draw	redraws the image, applying filters.
.TP
.I u
undo	goes to image before draw
.TP
.I SPACE
pause	pause the preview (and transcode)
.TP
.I UP
fastfw	in pause mode, step forward 5 frames
.TP
.I RIGHT
slowfw	in pause mode, step forward 1 frame
.TP
.I DOWN
fastbw	in pause mode, step back 5 frames
.TP
.I LEFT
slowbw	in pause mode, step back 1 frame
.TP
.I q
display	toggle display of frames
.TP
.I s
slower	slow down
.TP
.I f
faster	speed up
.TP
.I y
toggle	toggle displaying only every 5 frames
.TP
.I j
grab	save a JPEG
.TP
.I r
rotate	rotate AVI file after next keyframe
.TP
.RE
(*) all commands must be prefixed with "preview ".
.RE
.TP 4
\fBresample\fP - \fBaudio resampling filter plugin\fP
\fBresample\fP was written by Thomas Oestreich. The version documented here is v0.1.4 (2003-08-22). This is a audio filter. It is a pre-processing only filter.
.TP 4
\fBskip\fP - \fBskip all listed frames\fP
\fBskip\fP was written by Thomas Oestreich. The version documented here is v0.0.1 (2001-11-27). This is a video and audio filter. It is a pre-processing only filter.
.IP
.RS
\(bu
.I fstart1-fend1 [ fstart2-fend2 [ .. ] ]
= \fI%s\fP
.RS 3
apply filter [start-end] frames
.RE
.RE
.TP 4
\fBslowmo\fP - \fBvery cheap slow-motion effect\fP
\fBslowmo\fP was written by Tilmann Bitterberg. The version documented here is v0.3 (2003-29-11). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.IP
.RS
.IP
This filter produces a simple slow-motion effect by
duplicating certain frames. I have seen this effect
on TV and despite its the simple algorithm it works
quite well. The filter has no options.
.RE
.TP 4
\fBsmartbob\fP - \fBMotion-adaptive deinterlacing for double-frame-rate output.\fP
\fBsmartbob\fP was written by Donald Graft, Tilmann Bitterberg. The version documented here is v1.1beta2 (2003-06-23). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I motionOnly
= \fI%d\fP  [default \fI0\fP]
.RS 3
Show motion areas only
.RE
\(bu
.I shiftEven
= \fI%d\fP  [default \fI0\fP]
.RS 3
Blend instead of interpolate in motion areas
.RE
\(bu
.I threshold
= \fI%d\fP  [default \fI12\fP]
.RS 3
Motion Threshold
.RE
\(bu
.I denoise
= \fI%d\fP  [default \fI1\fP]
.RS 3
Phase shift
.RE
.IP
This filter only makes sense when fed by -J doublefps.
It will take the field-frames which filter_doublefps
produces and generates full-sized motion adaptive deinterlaced
output at the double import framerate.
.RE
.TP 4
\fBsmartdeinter\fP - \fBVirtualDub's smart deinterlacer\fP
\fBsmartdeinter\fP was written by Donald Graft. The version documented here is v2.7b (2003-02-01). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I motionOnly
= \fI%d\fP  [default \fI0\fP]
.RS 3
Show motion areas only
.RE
\(bu
.I Blend
= \fI%d\fP  [default \fI0\fP]
.RS 3
Blend instead of interpolate in motion areas
.RE
\(bu
.I threshold
= \fI%d\fP  [default \fI15\fP]
.RS 3
Motion Threshold
.RE
\(bu
.I scenethreshold
= \fI%d\fP  [default \fI100\fP]
.RS 3
Scene Change Threshold
.RE
\(bu
.I fieldShift
= \fI%d\fP  [default \fI0\fP]
.RS 3
Phase shift
.RE
\(bu
.I inswap
= \fI%d\fP  [default \fI0\fP]
.RS 3
Field swap before phase shift
.RE
\(bu
.I outswap
= \fI%d\fP  [default \fI0\fP]
.RS 3
Field swap after phase shift
.RE
\(bu
.I noMotion
= \fI%d\fP  [default \fI0\fP]
.RS 3
Disable motion processing
.RE
\(bu
.I highq
= \fI%d\fP  [default \fI0\fP]
.RS 3
Motion map denoising for field-only
.RE
\(bu
.I diffmode
= \fI%d\fP  [default \fI0\fP]
.RS 3
Motion Detection (0=frame, 1=field, 2=both)
.RE
\(bu
.I colordiff
= \fI%d\fP  [default \fI1\fP]
.RS 3
Compare color channels instead of luma
.RE
\(bu
.I cubic
= \fI%d\fP  [default \fI0\fP]
.RS 3
Use cubic for interpolation
.RE
.IP
This filter provides a smart, motion-based deinterlacing
capability. In static picture areas, interlacing artifacts do not
appear, so data from both fields is used to provide full detail. In
moving areas, deinterlacing is performed
.RE
.TP 4
\fBsmartyuv\fP - \fBMotion-adaptive deinterlacing\fP
\fBsmartyuv\fP was written by Tilmann Bitterberg. The version documented here is 0.1.4 (2003-10-13). This is a video filter. It can handle YUV mode only. It is a pre-processing only filter.
.IP
.RS
\(bu
.I motionOnly
= \fI%d\fP  [default \fI0\fP]
.RS 3
Show motion areas only, blacking out static areas
.RE
\(bu
.I diffmode
= \fI%d\fP  [default \fI0\fP]
.RS 3
Motion Detection (0=frame, 1=field, 2=both)
.RE
\(bu
.I threshold
= \fI%d\fP  [default \fI14\fP]
.RS 3
Motion Threshold (luma)
.RE
\(bu
.I chromathres
= \fI%d\fP  [default \fI7\fP]
.RS 3
Motion Threshold (chroma)
.RE
\(bu
.I scenethres
= \fI%d\fP  [default \fI31\fP]
.RS 3
Threshold for detecting scenechanges
.RE
\(bu
.I highq
= \fI%d\fP  [default \fI1\fP]
.RS 3
High-Quality processing (motion Map denoising)
.RE
\(bu
.I cubic
= \fI%d\fP  [default \fI1\fP]
.RS 3
Do cubic interpolation
.RE
\(bu
.I Blend
= \fI%d\fP  [default \fI1\fP]
.RS 3
Blend the frames for deinterlacing
.RE
\(bu
.I doChroma
= \fI%d\fP  [default \fI1\fP]
.RS 3
Enable chroma processing (slower but more accurate)
.RE
\(bu
.I verbose
= \fI%d\fP  [default \fI0\fP]
.RS 3
Verbose mode
.RE
.IP
This filter is basically a rewrite of the
smartdeinter filter by Donald Graft (without advanced processing
options) for YUV mode only. Its faster than using the smartdeinter
in YUV mode and is also tuned with its threshold settings for YUV
mode. The filter detects motion and static areas in an image and
only deinterlaces (either by blending or by cubic interpolation)
the moving areas. The result is an image with high detail in
static areas, no information is lost there.

The threshold settings should be sufficent for most users. As a
rule of thumb, I recommend setting the chroma threshold to about
the half of the luma threshold. If you want more deinterlacing,
lower the thresholds. The scene threshold can be easily found by
turning on verbose mode and the preview filter. In verbose mode,
the filter will print out, when it detects a scene change. If
scenechanges go by unnoticed, lower the scene threshold. You can
completly disable chroma processing with the doChroma=0 option.
Here is a sample commandline

-J smartyuv=highq=1:diffmode=2:cubic=1:Blend=1:chromathres=4:threshold=8:doChroma=1
.RE
.TP 4
\fBsmooth\fP - \fB(single-frame) smoothing plugin\fP
\fBsmooth\fP was written by Chad Page. The version documented here is v0.2.3 (2003-03-27). This is a video filter. It can handle YUV mode only. It is a pre-processing only filter. It supports multiple instances.
.IP
.RS
\(bu
.I strength
= \fI%f\fP  [default \fI0.25\fP]
.RS 3
Blending factor
.RE
\(bu
.I cdiff
= \fI%d\fP  [default \fI6\fP]
.RS 3
Max difference in chroma values
.RE
\(bu
.I ldiff
= \fI%d\fP  [default \fI8\fP]
.RS 3
Max difference in luma value
.RE
\(bu
.I range
= \fI%d\fP  [default \fI4\fP]
.RS 3
Search Range
.RE
.IP
"single-frame" means it only works with the current frame, it does not need the
next or the previous frame for operation. Usually smoothing is done by talking
the data of previous frames into account to see which parts of the picture can
be "safely" smoothed, this filter only needs one frame.
.RE
.IP
Usage -J subtitler="[no_objects] [subtitle_file=s]
[color_depth=n]
[font_dir=s] [font=n] [font_factor=f
[frame_offset=n]
[debug] [help]"
f is float, h is hex, n is integer, s is string.

no_objects           disables subtitles and other objects (off).
.br
color_depth=         32 or 24 (overrides X auto) (32).
.br
font=                0 or 1, 1 gives strange symbols... (0).
.br
font_dir=            place where font.desc is (~/.subtitles/font).
.br
font_factor=         .1 to 100 outline characters (10.75).
.br
frame_offset=        positive (text later) or negative (earlier) integer (0).
.br
subtitle_file=       pathfilename.ppml location of ppml file (~/.subtitles/demo.ppml).
.br
debug                prints debug messages (off).
.br
help                 prints this list and exit.
.RE
.RE
.TP 4
\fBtestframe\fP - \fBgenerate stream of testframes\fP
\fBtestframe\fP was written by Thomas Oestreich. The version documented here is v0.1.3 (2003-09-04). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I mode
= \fI%d\fP  [default \fI0\fP]
.RS 3
Choose the test pattern (0-4 interlaced, 5 colorfull)
.RE
.RE
.TP 4
\fBtext\fP - \fBwrite text in the image\fP
\fBtext\fP was written by Tilmann Bitterberg. The version documented here is v0.1.4 (2004-02-14). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I range
= \fI%u-%u/%d\fP  [default \fI0-4294967295/1\fP]
.RS 3
apply filter to [start-end]/step frames
.RE
\(bu
.I string
= \fI%s\fP
.RS 3
text to display (no ':') [defaults to `date`]
.RE
\(bu
.I font
= \fI%s\fP
.RS 3
full path to font file [defaults to arial.ttf]
.RE
\(bu
.I points
= \fI%d\fP  [default \fI25\fP]
.RS 3
size of font (in points)
.RE
\(bu
.I dpi
= \fI%d\fP  [default \fI96\fP]
.RS 3
resolution of font (in dpi)
.RE
\(bu
.I fade
= \fI%d\fP  [default \fI0\fP]
.RS 3
fade in/out (0=off, 1=slow, 10=fast)
.RE
\(bu
.I antialias
= \fI%d\fP  [default \fI1\fP]
.RS 3
Anti-Alias text (0=off 1=on)
.RE
\(bu
.I pos
= \fI%dx%d\fP  [default \fI0x0\fP]
.RS 3
Position (0-width x 0-height)
.RE
\(bu
.I posdef
= \fI%d\fP  [default \fI0\fP]
.RS 3
Position (0=None 1=TopL 2=TopR 3=BotL 4=BotR 5=Cent 6=BotCent)
.RE
\(bu
.I notransparent
(bool)
.RS 3
disable transparency (enables block box)
.RE
.IP
see /docs/filter_text.txt
.RE
.TP 4
\fBtomsmocomp\fP - \fBTom's MoComp deinterlacing filter\fP
\fBtomsmocomp\fP was written by Tom Barry et al.. The version documented here is v0.1 (2004-07-31). This is a video filter. It can handle YUV and YUV422 mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I TopFirst
= \fI%d\fP  [default \fI1\fP]
.RS 3
Assume the top field should be displayed first
.RE
\(bu
.I SearchEffort
= \fI%d\fP  [default \fI15\fP]
.RS 3
CPU time used to find moved pixels
.RE
\(bu
.I UseStrangeBob
= \fI%d\fP  [default \fI0\fP]
.RS 3
?Unknown?
.RE
\(bu
.I CpuFlags
= \fI%x\fP  [default \fI5f\fP]
.RS 3
Manual specification of CPU capabilities
.RE
.RE
.TP 4
\fBunsharp\fP - \fBunsharp mask & gaussian blur\fP
\fBunsharp\fP was written by Remi Guyomarch. The version documented here is v1.0.1 (2003-10-27). This is a video filter. It can handle YUV mode only. It is a post-processing only filter.
.IP
.RS
\(bu
.I amount
= \fI%f\fP  [default \fI0.0\fP]
.RS 3
Luma and chroma (un)sharpness amount
.RE
\(bu
.I matrix
= \fI%dx%d\fP  [default \fI0x0\fP]
.RS 3
Luma and chroma search matrix size
.RE
\(bu
.I luma
= \fI%f\fP  [default \fI0.0\fP]
.RS 3
Luma (un)sharpness amount
.RE
\(bu
.I chroma
= \fI%f\fP  [default \fI0.0\fP]
.RS 3
Chroma (un)sharpness amount
.RE
\(bu
.I luma_matrix
= \fI%dx%d\fP  [default \fI0x0\fP]
.RS 3
Luma search matrix size
.RE
\(bu
.I chroma_matrix
= \fI%dx%d\fP  [default \fI0x0\fP]
.RS 3
Chroma search matrix size
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI0\fP]
.RS 3
run as a pre filter
.RE
.IP
This filter blurs or sharpens an image depending on
the sign of "amount". You can either set amount for
both luma and chroma or you can set it individually
(recommended). A positive value for amount will sharpen
the image, a negative value will blur it. A sane range
for amount is -1.5 to 1.5.

The matrix sizes must be odd and define the
range/strength of the effect. Sensible ranges are 3x3
to 7x7.

It sometimes makes sense to sharpen the sharpen the
luma and to blur the chroma. Sample string is:

luma=0.8:luma_matrix=7x5:chroma=-0.2:chroma_matrix=3x3
.RE
.TP 4
\fBwhitebalance\fP - \fBWhite Balance Filter - correct images with a broken white balance\fP
\fBwhitebalance\fP was written by Guillaume Cottenceau. The version documented here is v0.1 (2003-10-01). This is a video filter. It can handle RGB and YUV mode. It is a pre-processing only filter.
.IP
.RS
\(bu
.I level
= \fI%d\fP  [default \fI40\fP]
.RS 3
Level of blue-to-yellow white balance shifting (can be negative)
.RE
\(bu
.I limit
= \fI%s\fP
.RS 3
Limit to specified ranges (+fnumber toggles on, -fnumber toggles off)
.RE
.IP
This filter allows correcting movies with a broken white balance, e.g. bluish movies.
.RE
.TP 4
\fBxharpen\fP - \fBVirtualDub's XSharpen Filter\fP
\fBxharpen\fP was written by Donald Graft, Tilmann Bitterberg. The version documented here is (1.0b2) (2003-02-12). This is a video filter. It can handle RGB and YUV mode. It is a post-processing only filter.
.IP
.RS
\(bu
.I strength
= \fI%d\fP  [default \fI200\fP]
.RS 3
How much  of the effect
.RE
\(bu
.I threshold
= \fI%d\fP  [default \fI255\fP]
.RS 3
How close a pixel must be to the brightest or dimmest pixel to be mapped
.RE
.IP
This filter performs a subtle but useful sharpening effect. The
result is a sharpening effect that not only avoids amplifying
noise, but also tends to reduce it. A welcome side effect is that
files processed with this filter tend to compress to smaller files.

  Strength 'strength' (0-255) [200]
    When this value is 255, mapped pixels are not blended with the original pixel values, so a full-strength effect is obtained. As the value is reduced, each mapped pixel is blended with more of the original pixel. At a value of 0, the original pixels are passed through and there is no sharpening effect.

  Threshold 'threshold' (0-255) [255]
    This value determines how close a pixel must be to the brightest or dimmest pixel to be mapped. If a pixel is more than threshold away from the brightest or dimmest pixel, it is not mapped.  Thus, as the threshold is reduced, pixels in the mid range start to be spared.
.RE
.TP 4
\fByuvdenoise\fP - \fBmjpegs YUV denoiser\fP
\fByuvdenoise\fP was written by Stefan Fendt, Tilmann Bitterberg. The version documented here is v0.2.1 (2003-11-26). This is a video filter. It can handle YUV mode only. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
\(bu
.I radius
= \fI%d\fP  [default \fI8\fP]
.RS 3
Search radius
.RE
\(bu
.I threshold
= \fI%d\fP  [default \fI5\fP]
.RS 3
Denoiser threshold
.RE
\(bu
.I pp_threshold
= \fI%d\fP  [default \fI4\fP]
.RS 3
Pass II threshold
.RE
\(bu
.I delay
= \fI%d\fP  [default \fI3\fP]
.RS 3
Average 'n' frames for a time-lowpassed pixel
.RE
\(bu
.I postprocess
= \fI%d\fP  [default \fI1\fP]
.RS 3
Filter internal postprocessing
.RE
\(bu
.I luma_contrast
= \fI%d\fP  [default \fI100\fP]
.RS 3
Luminance contrast in percent
.RE
\(bu
.I chroma_contrast
= \fI%d\fP  [default \fI100\fP]
.RS 3
Chrominance contrast in percent.
.RE
\(bu
.I sharpen
= \fI%d\fP  [default \fI125\fP]
.RS 3
Sharpness in percent
.RE
\(bu
.I deinterlace
= \fI%d\fP  [default \fI0\fP]
.RS 3
Force deinterlacing
.RE
\(bu
.I mode
= \fI%d\fP  [default \fI0\fP]
.RS 3
[0]: Progressive [1]: Interlaced [2]: Fast
.RE
\(bu
.I scene_thres
= \fI%d%%\fP  [default \fI50\fP]
.RS 3
Blocks where motion estimation should fail before scenechange
.RE
\(bu
.I block_thres
= \fI%d\fP  [default \fI1024\fP]
.RS 3
Every SAD value greater than this will be considered bad
.RE
\(bu
.I do_reset
= \fI%d\fP  [default \fI2\fP]
.RS 3
Reset the filter for `n' frames after a scene
.RE
\(bu
.I increment_cr
= \fI%d\fP  [default \fI2\fP]
.RS 3
Increment Cr with constant
.RE
\(bu
.I increment_cb
= \fI%d\fP  [default \fI2\fP]
.RS 3
Increment Cb with constant
.RE
\(bu
.I border
= \fI%dx%d-%dx%d\fP  [default \fI0x0-32x32\fP]
.RS 3
Active image area
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI0\fP]
.RS 3
run this filter as a pre-processing filter
.RE
.IP
see /docs/filter_yuvdenoise.txt
.RE
.TP 4
\fByuvmedian\fP - \fBmjpegs YUV median filter\fP
\fByuvmedian\fP was written by Mike Bernson, Tilmann Bitterberg. The version documented here is v0.1.0 (2003-01-24). This is a video filter. It can handle YUV mode only. It can be used as a pre-processing or as a post-processing filter.
.IP
.RS
\(bu
.I radius_luma
= \fI%d\fP  [default \fI2\fP]
.RS 3
Radius for median (luma)
.RE
\(bu
.I radius_chroma
= \fI%d\fP  [default \fI2\fP]
.RS 3
Radius for median (chroma)
.RE
\(bu
.I threshold_luma
= \fI%d\fP  [default \fI2\fP]
.RS 3
Trigger threshold (luma)
.RE
\(bu
.I threshold_chroma
= \fI%d\fP  [default \fI2\fP]
.RS 3
Trigger threshold (chroma)
.RE
\(bu
.I interlace
= \fI%d\fP  [default \fI0\fP]
.RS 3
Treat input as interlaced
.RE
\(bu
.I pre
= \fI%d\fP  [default \fI1\fP]
.RS 3
Run as a PRE filter
.RE
.RE
.\" Here ends the generated filter part, produced by make-filter-man.sh
.PP
.SH NOTES
.TP
*
Most source material parameter are auto-detected.
.TP
*
Clipping region options are expanded symmetrically.  Examples:
.RS
.LP
-j 80 will be expanded to -j 80,0,80,0
.LP
-j 80,8 will be expanded to -j 80,8,80,8
.LP
-j 80,8,10 will be expanded to -j 80,8,10,8
.RE
.TP
*
maximum image size is 1920x1088.
.TP
*
The video frame operations ordering is fixed: "-j -I -X -B -Z -Y -r -z
-l -k -K -G -C" (executed from left to right).
.TP
*
Shrinking the image with '-B' is not possible if the image
width/height is not a multiple of 8, 16 or 32.
.TP
*
Expanding the image with '-X' is not possible if the image
width/height is not a multiple of 8, 16 or 32.
.TP
*
The final frame width/height should be a multiple of 8. (to avoid
encoding problems with some codecs)
.RS
.IP 1.
Reducing the video height/width by 2,4,8 Option '-r factor' can be
used to shrink the video image by a constant factor, this factor can
be 2,4 or 8.
.IP 2.
Clipping and changing the aspect ratio
.I transcode
uses 3 steps to produce the input image for the export modules
.RS
.IP 1.
Clipping of the input image.
.IP 2.
Changing the aspect ratio of the 1) output.
.IP 3.
Clipping of the 2) output.
.RE
.RE
.TP
*
.I Bits per pixel
(bits/pixel) is a value transcode calculates and prints when starting up. It is
mainly useful when encoding to MPEG4 (xvid, divx, etc). You'll see line like
.RS

[transcode] V: bits/pixel       | 0.237

Simplified said, bits/pixel quantifies how good an encode will be. Although
this value depends heavily on the used input material, as a general rule of
thump it can be said that values greater or close to 0.2 will result in good
encodes, encodes with values less than 0.15 will have noticeable artifacts.

.I Bits per pixel
depends on the resolution, bitrate and frames per second. If you have a low
value ( < 0.15), you might want to raise the bitrate or encode at a lower
resolution. The exact formula is

           bitrate*1000
  bpp =  ----------------
         width*height*fps

.RE
.TP
*
.I AC3 / Multiple channels

When you do import an audio stream which has more then two audio channels \-
this is usually the case for AC3 audio \- transcode will automagically downmix
to two channels (stereo). You'll see line like
.RS

[transcode] A: downmix          | 5 channels -> 2 channels

This is done, because most encoders and audio filters can not handle more than
2 channels correctly. The PCM internal representation does not support more
than two channels, audio will be downmixed to stereo
.B No
downmix will happen, if you use AC3 as the internal audio codec or use audio
pass-through.
.RE

.SH EXAMPLES
The following command will read it's input from the DVD drive (I
assume \fI/dev/dvd\fP is a symbolic link to the actual DVD device) and
produce a splitted divx4 movie according to the chapter information on
the DVD medium.  The output files will be named
\fImy_movie-ch00.avi\fP, \fImy_movie-ch01.avi\fP ...
.LP
.PD 0
.RS
.nf
\fBtranscode -i /dev/dvd/ -x dvd -j 16,0 -B 5,0 \\\fP
.B -Y 40,8 -s 4.47 -U my_movie -y xvid -w 1618
.fi
.RE
.PD 1
.LP
Option
.B -j 16,0
will be expanded to
.B -j 16,0,16,0
and results in 16 rows from the top and the bottom of the image to be
cut off.  This may be usefull if the source consists of black top and
bottom bars.
.LP
Option
.B -B 5,0
tells \fItranscode\fP to shrink the resulting image by 5*32=160 rows
in height.
.LP
Option
.B -Y 40,8
will be expanded to
.B -Y 40,8,40,8
and tells \fItranscode\fP to ...
.LP
Option
.B -s 4.47
tells \fItranscode\fP to increase audio volume by a factor 4.47.
.LP
Option
.B -U my_movie
tells \fItranscode\fP to operate in chapter mode and produce output
to files named \fImy_movie-ch00.avi\fP, \fImy_movie-ch01.avi\fP...
.br
You can either merge the files afterwards with avimerge or add the option
--no_split to the command line.
.LP
Option
.B -y xvid
tells \fItranscode\fP to use the export module export_xvid.so which in turn uses the XviD encoder to encode the video.
.LP
Option
.B -w 1618
tells \fItranscode\fP to set the encoder bitrate to 1618 which is
lower than the default of 1800 and results in smaller files with the
loss of visual quality.
.TP
Lets assume that you have an NTSC DVD (720x480) and you want to make an NTSC-SVCD

The frame size of the DVD movie is 720x480 @ 16:9. For the purpose of
frame resizing, the width 720 is not relavant (that is, it will not be
used in the following reasoning). It is not needed because the original
frame size is really defined by the frame height and aspect ratio.
The _final result_ should be 640x480, encoded as 480x480 @ 4:3 (the
height 480 multiplied by the aspect ratio 4:3 gives the width 640).
This same frame size (640x480) can also be encoded as 640x360 @ 16:9
(the height 360 multiplied by the aspect ratio 16:9 gives the width
640).

As the _original video_ has aspect ratio 16:9, first we resize to
640x360, keeping that aspect ratio. But the aspect ratio has to be
changed to 4:3. To find the frame size in the new aspect ratio the
height 360 is multiplied by the new aspect ratio, giving the width
480. This is accomplished with the transcode options
"--export_asr 2 -Z 480x360,fast".

To avoid stretching the video height in this change (because the new
aspect ratio is less than the original), black borders should be added
at the top and bottom of the video, bringing the frame to the desired
480x480 @ 4:3 size. The transcode option for this is "-Y -60,0,-60,0".

If for some reason (maybe a subtitle filter) the black borders (of height 60
each) should be added before resizing the frame and changing the aspect ratio
to 4:3. One reason for that would be the need of running a _pre_ filter after
adding the black borders. Then the options "-j" or "--pre_clip" can be used
instead of "-Y". In this case the black border height has to be
recalculated by applying the aspect ratio 4:3 to the value already
found: 60 * (4/3) = 80. The transcode options "-j -80,0,-80,0" or
"--pre_clip -80,0,-80,0" are then used instead of "-Y -60,0,-60,0", and
"-Z 480x360,fast" is replaced by "-Z 480x480,fast".

.SH AUTHORS
.I transcode
was written by Thomas Oestreich <ostreich@theorie.physik.uni-goettingen.de> and
Tilmann Bitterberg with contributions from many others.  See the \fIAUTHORS\fP
file for details.

.SH SEE ALSO
.BR avifix (1),
.BR avisync (1),
.BR avimerge (1),
.BR avisplit (1),
.BR tcprobe (1),
.BR tcscan (1),
.BR tccat (1),
.BR tcdemux (1),
.BR tcextract (1),
.BR tcdecode (1),
.BR tcmodinfo (1),
.BR tcxmlcheck (1),
.BR transcode (1)
.br
.SH WWW
Frequently asked questions (FAQ) at
.br
.UR
http://www.transcoding.org/cgi-bin/transcode?Transcode_FAQ
.UE
.br
Example transcode sessions
.br
.UR
http://www.transcoding.org/cgi-bin/transcode?Command_Examples
.UE
.SH BUGS
Yes, there are bugs in transcode!
Do your part and report them immediately.
For details, see
.br
.UR
http://www.transcoding.org/cgi-bin/transcode?Reporting_Problems
.UE
